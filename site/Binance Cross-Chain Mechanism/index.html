<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Binance Chain Community" /><link rel="canonical" href="https://google.com/Binance%20Cross-Chain%20Mechanism/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>BC AND BSC Cross-Chain Mechanism - Binance</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "BC AND BSC Cross-Chain Mechanism";
        var mkdocs_page_input_path = "Binance Cross-Chain Mechanism.md";
        var mkdocs_page_url = "/Binance%20Cross-Chain%20Mechanism/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Binance
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">BNB Chain</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../GettingStarted/">GettingStarted</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../BSCApplicationSide/">BSCApplicationSideChain</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../BNBSmartChainIntro/">BNBSmartChain</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../BNBSmartChainCoreConcept/">BNB(SC)Core Concept</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">BC AND BSC Cross-Chain Mechanism</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#cross-chain-communication">Cross-Chain Communication</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#architecture-diagram">Architecture Diagram​</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#build-in-system-contract">Build-in System Contract</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#disclaimer">Disclaimer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#on-chain-light-client">On-Chain Light Client</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#precompile-contract">Precompile Contract​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#solidity-contract">Solidity Contract</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#other-build-in-system-contract">Other Build-in System Contract​</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cross-chain-transfer-token-transfer">Cross-Chain Transfer Token Transfer</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#verify-token-info">Verify Token Info​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transfer-bnb-from-bc-to-bsc">Transfer BNB from BC to BSC​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transfer-bnb-from-bsc-to-bc">Transfer BNB from BSC to BC​</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#transferout">transferOut​</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#batchtransferoutbnb">batchTransferOutBNB​</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transfer-bep2-to-bsc">Transfer BEP2 to BSC​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transfer-bep20-to-bc">Transfer BEP20 to BC​</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#transferout_1">transferOut</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mint">Mint​</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bsc-relayer">BSC Relayer</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#monitor-and-parse-cross-chain-event">Monitor and Parse Cross Chain Event​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#build-tendermint-header-and-query-cross-chain-package">Build Tendermint Header and Query Cross Chain Package​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#query-cross-chain-package-with-merkle-proof">Query Cross Chain Package With Merkle Proof​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#call-build-in-system-contract">Call Build-In System Contract​</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#sync-bc-header">Sync BC Header​</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#deliver-cross-chain-package">Deliver Cross Chain Package​</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#incentive-mechanism-for-bsc-relayer">Incentive Mechanism for BSC Relayer</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#principle">Principle​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rewards-source-and-allocation">Rewards Source and Allocation​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rewards-distribution-formula">Rewards Distribution Formula​</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#weight-formula-for-package-relayers">Weight formula for package relayers:​</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#weight-formula-for-header-relayers">Weight formula for header relayers:​</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#other-consideration">Other Consideration​</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#oracle-module">Oracle Module</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#oracle-process">Oracle Process​</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bridge-module">Bridge Module​</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#oracle-relayer">Oracle Relayer</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../GovernanceofBsc/">Governance of BSC</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../tools/">Tools</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Develop/">Develop</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Binance</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li><li>BC AND BSC Cross-Chain Mechanism</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="architecture">Architecture</h1>
<h2 id="cross-chain-communication"><strong>Cross-Chain Communication</strong></h2>
<p>A native cross chain communication protocol is developed between BC (Beacon Chain) and BSC (BNB Smart Chain). It has the following key parts:</p>
<ul>
<li>Build-in System Contract</li>
<li>Oracle on Beacon Chain</li>
<li>BSC Relayer</li>
<li>BSC Relayer Incentive Mechanism</li>
<li>Oracle Relayer</li>
</ul>
<h3 id="architecture-diagram"><strong>Architecture Diagram​</strong></h3>
<p>The following diagram depicts the architecture of the cross-transfer mechanism.</p>
<p><img alt="Screenshot" src="../img/cross-transfer-architecture.png" /></p>
<h2 id="build-in-system-contract">Build-in System Contract</h2>
<h4 id="disclaimer"><strong>Disclaimer</strong></h4>
<p>​
<strong>The software and related documentation are under active development, all subject to potential future change without notification and not ready for production use. The code and security audit have not been fully completed and are not ready for any bug bounty. We advise you to be careful and experiment on the network at your own risk. Stay safe out there.</strong></p>
<p>GitHub Implementation link: <a href="" title="https://github.com/bnb-chain/bsc-genesis-contract">https://github.com/bnb-chain/bsc-genesis-contract</a></p>
<table>
<thead>
<tr>
<th>Contract Name</th>
<th>Contract Address</th>
<th>ABI file</th>
</tr>
</thead>
<tbody>
<tr>
<td>BSCValidatorSet Contract</td>
<td>0x0000000000000000000000000000000000001000</td>
<td><a href="">bscvalidatorset</a></td>
</tr>
<tr>
<td>Liveness Slash Contract</td>
<td>0x0000000000000000000000000000000000001001</td>
<td><a href="">slashindicator</a></td>
</tr>
<tr>
<td>SystemReward Contract</td>
<td>0x0000000000000000000000000000000000001002</td>
<td><a href="">systemreward</a></td>
</tr>
<tr>
<td>TendermintLightClient Contract</td>
<td>0x0000000000000000000000000000000000001003</td>
<td><a href="">tendermintlightclient</a></td>
</tr>
<tr>
<td>TokenHub Contract</td>
<td>0x0000000000000000000000000000000000001004</td>
<td><a href="">tokenhub</a></td>
</tr>
<tr>
<td>RelayerIncentivize Contract</td>
<td>0x0000000000000000000000000000000000001005</td>
<td><a href="">relayerincentivize</a></td>
</tr>
<tr>
<td>RelayerHub Contract</td>
<td>0x0000000000000000000000000000000000001006</td>
<td><a href="">relayerhub</a></td>
</tr>
<tr>
<td>GovHub Contract</td>
<td>0x0000000000000000000000000000000000001007</td>
<td><a href="">govhub</a></td>
</tr>
<tr>
<td>TokenManager Contract</td>
<td>0x0000000000000000000000000000000000001008</td>
<td><a href="">tokenmanager</a></td>
</tr>
<tr>
<td>CrossChain Contract</td>
<td>0x0000000000000000000000000000000000002000</td>
<td><a href="">crosschain</a></td>
</tr>
</tbody>
</table>
<h3 id="on-chain-light-client">On-Chain Light Client</h3>
<p>​
The purpose of cross-chain interoperability is to enable one blockchain to function as a light-client of another. Since Beacon Chain is using a classical Byzantine Fault Tolerant consensus algorithm, light-client verification is cheap and easy: all we have to do is check validator signatures on the latest block, and verify a Merkle proof of the state.</p>
<p>In Tendermint, validators agree on a block before processing it. This means that the signatures and state root for that block aren't included until the next block. Thus, each block contains a field called LastCommit, which contains the votes responsible for committing the previous block, and a field in the block header called AppHash, which refers to the Merkle root hash of the application after processing the transactions from the previous block. So, if we want to verify the AppHash from height H, we need the signatures from LastCommit at height H+1. (And remember that this AppHash only contains the results from all transactions up to and including block H-1)</p>
<p>Unlike Proof-of-Work, the light-client protocol does not need to download and check all the headers in the blockchain - the client can always jump straight to the latest header available, so long as the validator set has not changed much. If the validator set is changing, the client needs to track these changes, which requires downloading headers for each block in which there is a significant change. Here, we will assume the validator set is constant, and postpone handling validator set changes for another time.</p>
<p>Ethereum platform supports stateless precompiled contract implemented with golang and normal contract implemented with solidity. As compared to normal contracts, precompiled contracts are more efficient and costs less gas, but they are stateless. However, on-chain light client must be stateful. So here we will try to a mixed approach: precompiled implemented contract(stateless calculation, such as signature verification) and normal contract (store validator set and trusted appHash).</p>
<p><img alt="ScreenShot" src="../img/lightclient.png" /></p>
<h3 id="precompile-contract">Precompile Contract​</h3>
<p><strong>Validate Tendermint Header​</strong></p>
<p>This contract implements tendermint header verification algorithm. The input parameters contain the trusted consensus state and a new tendermint header. The validation algorithm will verify the new tendermint header against the trusted consensus state. If the new header is valid, a new consensus state will be created and returned to caller. Otherwise, an error will be returned.</p>
<p><strong>Validate Merkle Proof​</strong></p>
<p>This contract implements a <a href="">Tendermint merkle proof verification algorithm</a>.</p>
<h3 id="solidity-contract">Solidity Contract</h3>
<p>​
<strong>Ten*dermint Light Client Contract​</strong></p>
<ol>
<li>ConsensusState: The first consensus state will be written in the constructor. Once a new tendermint header is verified, a new consensus state will be created.</li>
</ol>
<p>type ConsensusState struct {
  chainID              string
  height               int64
  appHash              []byte
  curValidatorSetHash  []byte
  nextValidatorSet     *tmtypes.ValidatorSet
}</p>
<ol>
<li>Tendermint Header: A relayer who want to sync new tendermint headers need to query BC to build this object. Then encode it to byte array and call syncTendermintHeader.</li>
</ol>
<pre><code class="language-golang">type Header struct {
    Header blockHeader
    Validator[] CurValidatorSet
    Validator[] NextValidatorSet
}
</code></pre>
<p>This contract implements the following four methods:</p>
<ol>
<li>function <strong>syncTendermintHeader</strong>(byte[] header, uint64 height)</li>
</ol>
<p><strong>syncTendermintHeader</strong> gets nearest consensus state by height and call validateTendermintHeader in precompiled contract to verify the tendermint header. If the success, a new consensus state will be saved.</p>
<ol>
<li>function <strong>getAppHash</strong>(uint64 height) returns(bytes32)</li>
</ol>
<p><strong>getAppHash</strong> provides a method to get the verified appHash at the specified height. Besides, If the header of the specified height have not be verified, then zero value will be returned.</p>
<ol>
<li>function <strong>isHeaderSynced</strong>(uint64 height) returns (bool)</li>
</ol>
<p><strong>isHeaderSynced</strong> provides a lower cost method to judge if the specified height has been synced.</p>
<ol>
<li>function <strong>getSubmitter</strong>(uint64 height) returns (address)</li>
</ol>
<p><strong>getSubmitter</strong> provides a method to get the submitter address of the specified header.</p>
<p><strong>Merkle Proof Verification Library​</strong></p>
<p>This library provides an util to verify merkle proof from BC. Contracts which need to verify Merkle proof just need to import this library.</p>
<p>function <strong>verifyMerkleProof</strong>(int64 height, byte[] key, byte[] value, byte[] proof) bool</p>
<p><strong>verifyMerkleProof</strong> reassembles user parameters and calls the above precompiled contract to validate the proof.</p>
<h3 id="other-build-in-system-contract">Other Build-in System Contract​</h3>
<ul>
<li><strong>TokenHub Contract</strong></li>
</ul>
<p>This contract focuses on cross chain token transfer.</p>
<ul>
<li><strong>TokenManager Contract</strong></li>
</ul>
<p>This contract focuses on binding and unbinding tokens on two chains.</p>
<ul>
<li><strong>BSCValidatorSet Contract</strong></li>
</ul>
<p>It is a watcher of validators change of BSC on Beacon Chain. It will interact with light client contracts to verify the interchain transaction, and apply the validator set change for BSC. It also stores rewarded gas fee of blocking for validators, and distribute it to validators when receiving cross chain package of validatorSet change.</p>
<ul>
<li><strong>System Reward Contract</strong></li>
</ul>
<p>The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract.</p>
<ul>
<li><strong>Liveness Slash Contract</strong></li>
</ul>
<p>The liveness of BSC relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators.</p>
<ul>
<li><strong>BscValidatorSet Contract</strong></li>
</ul>
<p>This contract focuses on handling staking change package from BC. It also provides the validatorset data query for BSC consensus engine.</p>
<ul>
<li><strong>RelayerHub Contract</strong></li>
</ul>
<p>This contract manages the authority of bsc-relayer. Someone who wants to run a bsc-relayer must call the contract to deposit some BNB to get the authorization.</p>
<ul>
<li><strong>Governance Contract</strong></li>
</ul>
<p>This contract handles the governance package from BC. The governance package contains the target contract address, parameter name and new parameter value. Once the package is verified, this contract will call the parameter update method of the target contract to update the parameter to new value.</p>
<ul>
<li><strong>Cross Chain Contract</strong></li>
</ul>
<p>This contract focuses on cross chain packages pretreatment and sending cross chain packages to BC by emit event. The packages pretreatment includes sequence validation and the merkle proof verification. Once they are passed, the package will be routed to application build-in system contract, such as tokenhub or bscvalidator. Besides, if tokenhub or bscvalidator wants to send packages to BC, they need to encode their packages with rlp and call this contract to send them.</p>
<h2 id="cross-chain-transfer-token-transfer">Cross-Chain Transfer Token Transfer</h2>
<p>Cross-chain transfers only support bound BEP2 or BEP8 tokens on BC and BEP20 tokens on BSC.</p>
<h3 id="verify-token-info"><strong>Verify Token Info​</strong></h3>
<p>First, you should make sure that it's already bound. For example, you could see the binding info of <strong>BNB</strong>:</p>
<pre><code>  ## mainnet
  bnbcli token info --symbol BNB --trust-node --node http://dataseed4.binance.org:80

  ## testnet
  tbnbcli token info --symbol BNB --trust-node --node http://data-seed-pre-0-s3.binance.org:80
</code></pre>
<p></br></p>
<pre><code>{
 "type": "bnbchain/Token",

 "value": {

   "name": "Binance Chain Native Token",

   "symbol": "BNB",

   "original_symbol": "BNB",

   "total_supply": "200000000.00000000",

   "owner": "tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy",

   "mintable": false,

   "contract_address": "0x0000000000000000000000000000000000000000",

   "contract_decimals": 18

 }
}
</code></pre>
<p>As BNB is the native token on both chains, so we use <code>0x0000000000000000000000000000000000000000</code> as the corresponding contract address. Besides, on BSC, the native token decimals is 18, while the decimals on BC is 8. So if you transfer 1e8:BNB to BSC, the recipient balance will gain 1e18.</p>
<h3 id="transfer-bnb-from-bc-to-bsc"><strong>Transfer BNB from BC to BSC​</strong></h3>
<p><strong>Example:</strong>  </p>
<pre><code>  ## mainnet
bnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Tigris --from owner --amount 100000000:BNB --node http://dataseed4.binance.org:80

  ## testnet
tbnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Ganges --from owner --amount 100000000:BNB --node http://data-seed-pre-0-s3.binance.org:80
</code></pre>
<p>Result:</p>
<pre><code>  Committed at block 465899 (tx hash: 68FFF82197E27A3EC14AFF8C99A035FA9CA7120312AA55E98D11DFC0F8D9F3B9, response: {Code:0 Data:[] Log:Msg 0:  Info: GasWanted:0 GasUsed:0 Events:[{Type: Attributes:[{Key:[84 114 97 110 115 102 101 114 79 117 116 83 101 113 117 101 110 99 101] Value:[49 49] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[69 120 112 105 114 101 84 105 109 101] Value:[49 53 57 55 53 52 51 49 57 51] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 114 111 115 115 84 114 97 110 115 102 101 114 79 117 116] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0})
</code></pre>
<h3 id="transfer-bnb-from-bsc-to-bc"><strong>Transfer BNB from BSC to BC​</strong></h3>
<h4 id="transferout"><strong>transferOut​</strong></h4>
<p>Call <strong>transferOut</strong> of <a href="">TokenHub contract</a> in <a href="">MyEtherWallet</a>:</p>
<p><img alt="Screenshot" src="../img/pasted%20image.png" /></p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>contractAddr</td>
<td>address</td>
<td>for BNB, the value must be 0x0000000000000000000000000000000000000000</td>
</tr>
<tr>
<td>recipient</td>
<td>address</td>
<td>decode bech32 address, starting with 0x . To transfer to hex string. This is a online too to decode bech32: <a href="" title="https://slowli.github.io/bech32-buffer/">https://slowli.github.io/bech32-buffer/</a></td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The BNB decimals on BSC is 18. If you want to transfer one BNB, then the value should be 1e18. Besides, the value must be N * 1e10</td>
</tr>
<tr>
<td>expireTime</td>
<td>uint256</td>
<td>Timestamp, counted by second</td>
</tr>
</tbody>
</table>
<p>The value here should follow this equation:</p>
<pre><code>  txValue = (amount + RelayFee)/1e18
</code></pre>
<p><code>RelayFee</code> should be 0.01BNB and it can be updated by on-chain governance. For example, if you transfer 1BNB from BSC to BC, the value should be at least 1.01BNB.</p>
<p>After all the above parameters have been set to proper values, users can click the transact button to build transactions, and metamask plugin will be ejected. Then users can click the confirm button in metamask to sign and broadcast transactions.</p>
<h4 id="batchtransferoutbnb"><strong>batchTransferOutBNB​</strong></h4>
<p>Call <strong>batchTransferOutBNB</strong> of TokenHub contract in MyEtherWallet:</p>
<p><img alt="Screenshot" src="../img/batchTransferOutBNB.png" /></p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>recipientAddrs</td>
<td>address[]</td>
<td>decode bech32 address to hex string. This is a online too to decode bech32: <a href="" title="https://slowli.github.io/bech32-buffer/0">https://slowli.github.io/bech32-buffer/0</a></td>
</tr>
<tr>
<td>amounts</td>
<td>uint256[]</td>
<td>amount for each recipient, should be N * 1e10</td>
</tr>
<tr>
<td>refundAddrs</td>
<td>address[]</td>
<td>sender can specify some address as the refund address if the cross chain transfer is failed.</td>
</tr>
<tr>
<td>expireTime</td>
<td>uint256</td>
<td>Timestamp, counted by second</td>
</tr>
</tbody>
</table>
<p>The value here should follow this equation:</p>
<pre><code>  txValue = (sumOfAmounts + RelayFee * batchSize)/1e18
</code></pre>
<h3 id="transfer-bep2-to-bsc"><strong>Transfer BEP2 to BSC​</strong></h3>
<p>Execute the following command to transfer ABC-A64 token to BSC:</p>
<pre><code>  ## mainnet
  bnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Tigris --from owner --amount 10000000000:ABC-A64 --node http://dataseed4.binance.org:80

  ## testnet
  tbnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Ganges --from owner --amount 10000000000:ABC-A64 --node http://data-seed-pre-0-s3.binance.org:80
</code></pre>
<h3 id="transfer-bep20-to-bc"><strong>Transfer BEP20 to BC​</strong></h3>
<p>Before calling <strong><em>transferOut</em>* or </strong>batchTransferOut<strong>, users need to call </strong>approve<strong> method to grant enough allowance to TokenHub contract. For </strong>transferOut<strong> method, the allowance should equal the transfer amount. For </strong>batchTransferOut**, the allowance should be the sum of the amount array.</p>
<h4 id="transferout_1"><strong>transferOut</strong></h4>
<p>​
<img alt="Screenshot" src="../img/pasted%20image1.png" /></p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>contractAddr  address</td>
<td>BEP20 contract address</td>
<td></td>
</tr>
<tr>
<td>recipient</td>
<td>address</td>
<td>decode bech32 address to hex string. This is a online too to decode bech32: <a href="" title="https://slowli.github.io/bech32-buffer/">https://slowli.github.io/bech32-buffer/</a></td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>BEP20 token amount. Here the decimals is 18, so the amount must be N * 1e10.</td>
</tr>
<tr>
<td>expireTime</td>
<td>uint256</td>
<td>Timestamp, counted by second</td>
</tr>
</tbody>
</table>
<p>The value here should be RelayFee.</p>
<h4 id="mint"><strong>Mint​</strong></h4>
<p>If both the BEP20 token and bep2 token are mintable, then token owners can still mint their tokens even after token binding. Besides, token owners need to ensure the total supply and the locked amount on both chains are still matched, otherwise, users might can’t transfer their tokens to another chain.</p>
<p><strong>Mint token on BC​</strong>
1. Execute the following command to mint 10000 ABC-A64:
        ## mainnet
        bnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Tigris --node http://dataseed4.binance.org:80</p>
<pre><code>    ## testnet
    tbnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Ganges --node http://data-seed-pre-0-s3.binance.org:80
</code></pre>
<ol>
<li>
<p>Mint token on BSC and lock the new minted token:</p>
</li>
<li>
<p>Call <strong>mint</strong> method of BEP20 contract, the mint amount should be 1e22.
Transfer all minted ABC token to tokenHub contract: <code>0x0000000000000000000000000000000000001004</code></p>
</li>
</ol>
<p><strong>Mint token on BSC​</strong>
1. Call <strong>mint</strong> of BEP20 contract to mint 10000 ABC, the mint amount should be 1e22(18 decimals).</p>
<ol>
<li>Mint token on BC and lock the new minted token:</li>
<li>
<p>Execute the following command to mint 10000 ABC-A64:</p>
<p>## mainnet
  bnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Tigris --node http://dataseed4.binance.org:80</p>
<p>## testnet
  tbnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Ganges --node http://data-seed-pre-0-s3.binance.org:80</p>
</li>
<li>
<p>Transfer all minted ABC-A64 token to the pure-code-controlled address: <code>tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr</code>(mainnet address: <code>bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj</code>)</p>
</li>
</ol>
<h2 id="bsc-relayer">BSC Relayer</h2>
<p>Relayers are responsible for submitting Cross-Chain Communication Packages between the two blockchains. Due to the heterogeneous parallel chain structure, two different types of Relayers are created.</p>
<p>Relayers for BC-to-BSC communication referred to as <strong>BSC Relayers</strong> are a standalone process that can be run by anyone, and anywhere, except that Relayers must register themselves onto BSC and deposit a certain amount of BNB. Only relaying requests from the registered Relayers will be accepted by BSC.</p>
<p>GitHub Implementation link: <a href="" title="https://github.com/bnb-chain/bsc-relayer">https://github.com/bnb-chain/bsc-relayer</a></p>
<p>Config Files: <a href="" title="https://github.com/bnb-chain/bsc-relayer-config">https://github.com/bnb-chain/bsc-relayer-config</a></p>
<h3 id="monitor-and-parse-cross-chain-event"><strong>Monitor and Parse Cross Chain Event​</strong></h3>
<p>As a BSC relayer, it must have proper configurations on the following three items:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>srcCrossChainID</td>
<td>uint16</td>
<td>CrossChainID of BC, the value is 1 for testnet</td>
</tr>
<tr>
<td>destCrossChainID</td>
<td>uint16</td>
<td>CrossChainID of BSC, the value is 96 for testnet</td>
</tr>
</tbody>
</table>
<p>A BSC relayer is required to parse all block results and pick out all events with event type “IBCPackage” from endBlock event table. This is an cross chain package event example:</p>
<pre><code>{
  "type": "IBCPackage",
  "attributes":
  [
   {
     "key": "IBCPackageInfo",
     "value": "96::8::19"
    }
  ]
}
</code></pre>
<p>BSC relayer should iterate all the attributes and parse the attribute value:</p>
<ol>
<li>Split the value with “::” and get a 4-length string array</li>
<li>Follow the following table to parse the 4 elements:</li>
</ol>
<table>
<thead>
<tr>
<th>Index</th>
<th>Description</th>
<th>Type</th>
<th>Example Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>CrossChainID  of destination chain</td>
<td>int16</td>
<td>96</td>
</tr>
<tr>
<td>1</td>
<td>channel id</td>
<td>int8</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>sequence</td>
<td>int64</td>
<td>19</td>
</tr>
</tbody>
</table>
<ol>
<li>Filter out attributes with mismatched destination chain CrossChainID.</li>
</ol>
<h3 id="build-tendermint-header-and-query-cross-chain-package"><strong>Build Tendermint Header and Query Cross Chain Package​</strong></h3>
<p><strong>Build Tendermint Header​</strong></p>
<pre><code>  import tmtypes "github.com/tendermint/tendermint/types"
  type Header struct {
    tmtypes.SignedHeader
    ValidatorSet     *tmtypes.ValidatorSet `json:"validator_set"`
    NextValidatorSet *tmtypes.ValidatorSet `json:"next_validator_set"`
    }
</code></pre>
<p>If a cross chain package event is found at height <strong>H</strong>, wait for block <strong>H+1</strong> and call the following rpc methods to build the above <strong>Header</strong> object:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>tmtypes.SignedHeader</td>
<td>{rpcEndpoint}/commit?height=H+1</td>
</tr>
<tr>
<td>ValidatorSet</td>
<td>{rpcEndpoint}/validators?height=H+1</td>
</tr>
<tr>
<td>NextValidatorSet</td>
<td>{rpcEndpoint}/validators?height=H+2</td>
</tr>
</tbody>
</table>
<p>Header Encoding in golang:</p>
<ol>
<li>Add dependency on <a href="">go-amino v0.14.1</a></li>
<li>Add dependency on <a href="">tendermint v0.32.3</a>:</li>
<li>Example golang code to encode <strong>Header</strong>:<pre><code>import (
amino "github.com/tendermint/go-amino"
tmtypes "github.com/tendermint/tendermint/types"
  )
var cdc = amino.NewCodec()
func init() {
 tmtypes.RegisterBlockAmino(cdc)
}

func EncodeHeader(h *Header) ([]byte, error) {
 bz, err := cdc.MarshalBinaryLengthPrefixed(h)
 if err != nil {
return nil, err
}
   return bz, nil
}
</code></pre>
</li>
</ol>
<h3 id="query-cross-chain-package-with-merkle-proof"><strong>Query Cross Chain Package With Merkle Proof​</strong></h3>
<ol>
<li>Query height: <strong>H</strong></li>
<li>Query path: <strong>/store/ibc/key</strong></li>
<li>Follow the table to build a 14-length byte array as query key:</li>
</ol>
<table>
<thead>
<tr>
<th>Name</th>
<th>Length</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td>1 bytes</td>
<td>0x00</td>
</tr>
<tr>
<td>source chain CrossChainID</td>
<td>2 bytes</td>
<td>srcCrossChainID in bsc relayer configuration</td>
</tr>
<tr>
<td>destination chain CrossChainID</td>
<td>2 bytes</td>
<td>destCrossChainID in bsc relayer configuration</td>
</tr>
<tr>
<td>channelID</td>
<td>1 bytes</td>
<td>channelID from event attribute</td>
</tr>
<tr>
<td>sequence</td>
<td>8 bytes</td>
<td>sequence from event attribute</td>
</tr>
</tbody>
</table>
<ol>
<li>Assemble the above parameters to the following rpc call.
      {rpcEndpoint}/abci_query?path={queryPath}&amp;data={queryKey}&amp;height={queryHeight}&amp;prove=true</li>
</ol>
<h3 id="call-build-in-system-contract"><strong>Call Build-In System Contract​</strong></h3>
<h4 id="sync-bc-header"><strong>Sync BC Header​</strong></h4>
<ul>
<li>function <strong>syncTendermintHeader</strong>(bytes calldata header, uint64 height)</li>
</ul>
<p>Call <strong>syncTendermintHeader</strong> of TendermintLightClient contract to sync BC header. The contract address is 0x0000000000000000000000000000000000001003. The “header” is the encoding result of <strong>Header</strong> and the height should be <strong>H+1</strong></p>
<h4 id="deliver-cross-chain-package"><strong>Deliver Cross Chain Package​</strong></h4>
<p>Call <strong>handlePackage</strong> of crosschain contract(0x0000000000000000000000000000000000002000) to deliver the cross chain packages:</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>msgBytes</td>
<td>[]byte</td>
<td>package bytes</td>
</tr>
<tr>
<td>proof</td>
<td>[]byte</td>
<td>merkle proof bytes</td>
</tr>
<tr>
<td>height</td>
<td>uint64</td>
<td>H+1</td>
</tr>
<tr>
<td>packageSequence</td>
<td>uint64</td>
<td>sequence from attribution value</td>
</tr>
<tr>
<td>channelId</td>
<td>uint64</td>
<td>channle id</td>
</tr>
</tbody>
</table>
<h2 id="incentive-mechanism-for-bsc-relayer">Incentive Mechanism for BSC Relayer</h2>
<p>The BSC relayers play an important role in relaying interchain packages from BC to BSC. All BSC relayers build their stable infrastructure, watch any event happened on the Beacon Chain, and act timely to get paid accordingly. The following discussion is about how to distribute the rewards to let the relayers are willing to make a long-term contribution.</p>
<h3 id="principle"><strong>Principle​</strong></h3>
<p>Considering the following points:</p>
<ol>
<li>Fairness, competitiveness, and redundancy: Everyone has a chance to run a relayer even on cheap hardware. It should be hard for someone to get all the rewards.</li>
<li>Simplicity.</li>
<li>Robustness: The relayer may have a strategy to make its largest profit accordingly, under any condition, the interchain communication should not be blocked.</li>
<li>Low Risk: The relayer should take a little risk to play in this game. For the top N relayers, they should gain enough rewards to cover the cost.</li>
</ol>
<p>It is tough hard to achieve all these goals; we make some trade-off on robustness and low risk in the following design.</p>
<h3 id="rewards-source-and-allocation"><strong>Rewards Source and Allocation​</strong></h3>
<p>We have three reward sources:</p>
<ol>
<li>Users paid rewards: Users who send <code>bind</code> or <code>cross chain transfer</code> transactions need to pay extra fee as BSC relayer rewards.</li>
<li>System rewards: Rewards comes from <code>SystemReward</code> contract.</li>
</ol>
<p>The role of relayers and their rewards comes from:</p>
<table>
<thead>
<tr>
<th>Relayer Behavior</th>
<th>Rewards come from</th>
</tr>
</thead>
<tbody>
<tr>
<td>User packages(bind, unbind, transfer) from BC to BSC</td>
<td>Users pay for the reward</td>
</tr>
<tr>
<td>System packages(staking, slash, governance) from BC to BSC</td>
<td>System reward</td>
</tr>
<tr>
<td>Relayer for sync tendermint header to light client contract</td>
<td>System reward</td>
</tr>
</tbody>
</table>
<h3 id="rewards-distribution-formula"><strong>Rewards Distribution Formula​</strong></h3>
<p>To prevent the relayer who has the best network always winning the game, we gather the reward into two reward pools (header relayer reward pool and package relayer reward pool) and reallocate to the relayers to achieve redundancy:</p>
<ol>
<li>S is a constant number of transactions that in around. Each round, there are S transactions, and the last transaction of the round will trigger reward distribution.</li>
<li>N is the maximum weight that a relayer can gain in a round. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i.</li>
<li>R is the total reward in this round.</li>
<li>Ki is the number of successful transactions from Relayer i.</li>
<li>Wi is the reward weight of Relayer i.</li>
<li>Ri is the rewards of Relayer i.</li>
</ol>
<h4 id="weight-formula-for-package-relayers"><strong>Weight formula for package relayers:​</strong></h4>
<p><img alt="Screenshot" src="../img/packageRelayerRewardformula.png" /></p>
<p><code>Rp</code> represents the total balance of package reward pool.</p>
<h4 id="weight-formula-for-header-relayers"><strong>Weight formula for header relayers:​</strong></h4>
<p><img alt="Screenshot" src="../img/headerRelayerRewardFormula-1.png" /></p>
<p><code>Rh</code> represents the total balance of header reward pool.</p>
<p><strong>We consider setting these parameters a reasonable value:</strong>
 ​
  1. S to be 100. Some rewards come from gas fee, we can not guarantee enough rewards during a small round, a large round may dismiss deviation and let relayer give up relaying when it has made its max profit.
  2. N to be 40. We think the redundancy of relayer around 3-5 is best. If N is too large, the redundancy will decrease. If N is too small, then there will not be enough relayers. Set N as 40 may be a reasonable value, at least 3 relayers can compete.
  3. The relayFee of a single package and the ratio of reward for header relayer can be modified by governance on Beacon Chain.</p>
<p><strong>Distribution And Claim Reward​</strong></p>
<p>In each round, the last package delivery transaction will trigger the reward distribution. Both the header reward pool and package reward pool will be distributed. However, the reward won't be paid directly to relayer accounts. The distribution algorithm just calculates rewards for all relayers and writes down the amounts. Relayers are required to actively send transactions to claim their own accumulated rewards.</p>
<h3 id="other-consideration"><strong>Other Consideration​</strong></h3>
<p><strong>System Reward Pool​</strong></p>
<p>The system reward pool can hold at most 100BNB for example, to prevent the pool get unnecessary income.</p>
<p>The client needs to query the balance of the contract to decide whether to distribute 1/16 of the transaction fee to the contract or not. It seems not that fair that some validators pay more to the reward pool than others, but this is random and will eventually become fair in the long run.</p>
<p>If there are not enough rewards in the pool, all the tokens in the pool will be distributed.</p>
<p>Block header sync transaction with validatorSet change will claim reward to relayers from system reward pool directly.</p>
<p><strong>Foul Play​</strong></p>
<p>For example, a relayer may deliver packages using a different address in round robin, we can’t recognize this. We try to introduce registration and BNB deposit for relayer to raise the cost of cheat. How it works:</p>
<ul>
<li>A BSC account needs to call the <code>register</code> of <a href="">RelayerHub</a> contract to deposit 100BNB(more or less than 100 BNB will be rejected) to become a BSC relayer.</li>
<li>Only a valid relayer can sync Beacon Chain Headers and deliver cross-chain packages.</li>
<li>Relayer can withdraw its deposit, but we will charge 0.1 BNB as the transaction fee so that it will receive 99.9 BNB back.</li>
<li>The charged fee will directly go to the system reward pool.</li>
</ul>
<h2 id="oracle-module">Oracle Module</h2>
<p>The <strong>oracle</strong> module is a common module like gov which is used to handle prophecy and claim. Prophecy means the validators want to reach a consensus on something, like cross chain transfer. Claim is raised by a validator and the content of claim is the cross chain transfer. When most of the validators (like 70%) claim the same thing on the prophecy, the winning claim will be executed.For oracle module is a common module, other module which depends on oracle module will register claim type and related hooks checking and handling claim. Each claim type has a sequence, oracle module should process prophecy and claim by sequence. When one prophecy is executed successfully, the sequence of the claim type will be increased by one.</p>
<h3 id="oracle-process"><strong>Oracle Process​</strong></h3>
<ol>
<li>Oracle module receives a claim message from validator, if the sequence is not current sequence, the claim message will be rejected.</li>
<li>If sequence is valid, the hooks of the claim type will check the claim message, if the claim message is invalid, then return</li>
<li>If the claim message is valid and it’s the first claim, the related prophecy will be created. If claim message is not the first claim, then it will be added to the existed prophecy.</li>
<li>If the power of validators which claim the same content reaches a threshold like 70%, the prophecy will be marked success and the hooks will execute the winning claim and the sequence of claim type will be increased.</li>
<li>If there is no chance that the validators will reach a consensus, the prophecy will be marked failed and the prophecy will be deleted and the validators should start over again.</li>
</ol>
<h3 id="bridge-module"><strong>Bridge Module​</strong></h3>
<p>Bridge module will process cross chain transactions. It contains two parts: transactions from BC to BSC and transactions from BSC to BC. For transactions from BSC to BC, it will depend on the oracle module. When the validators reach a consensus on a certain claim, the bridge module will process the transaction according to the claim, like transfer from BSC to BC. For transactions from BC to BSC, it will process the BC part of the transaction and write the related cross chain package for BSC.</p>
<h2 id="oracle-relayer">Oracle Relayer</h2>
<p>The relayer is a service which monitors events on BSC, builds and broadcasts transactions to BC. Each validator operator should maintain its own relayer service. The relayer service requires to have access to the validator operator private key. All relayer service independently witness the peggy contract events, then build transactions to claim events to BC oracle module.</p>
<p>The relay process:</p>
<ul>
<li>Continually listen for cross chain event</li>
<li>Parse the cross-chain transfer parameters from event data</li>
<li>Use this information to build an unsigned BC oracle transaction</li>
<li>Sign and broadcast transaction.
GitHub Implementation link: <a href="" title="https://github.com/bnb-chain/oracle-relayer">https://github.com/bnb-chain/oracle-relayer</a></li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../BNBSmartChainCoreConcept/" class="btn btn-neutral float-left" title="BNB(SC)Core Concept"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../GovernanceofBsc/" class="btn btn-neutral float-right" title="Governance of BSC">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../BNBSmartChainCoreConcept/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../GovernanceofBsc/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
