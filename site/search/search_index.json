{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"INTRODUCTION BNB Chain, one of the most popular blockchains in the world, dedicates to delivering its core infrastructure necessary for future public adoption, and always remains as a community-first and open-source ecosystem built on a permissionless and decentralized environment. Binance Chain and Binance Smart Chain have formed together as BNB Chain since February 15, 2022. BNB Chain comprises BNB Beacon Chain (previously Binance Chain) and BNB Smart Chain (previously Binance Smart Chain). While BNB (formerly called \u201cBinance Coin\u201d) has also been renamed as \u201cBuild and Build.\u201d The name change is not merely for welcoming the crypto world with more than 1 billion users but also to strengthen the delivery of the core infrastructure necessary for future public adoption and, most importantly, to build a better ecosystem for embracing the MetaFi. MetaFi is a concept that provides advanced and sophisticated DeFi Infra to all the different types of projects such as metaverse, GameFi, SocialFi, Web3, and NFTs and puts them under one umbrella \u2013 MetaFi. This document will show the whole picture of the BNB Chain, how it works, and what it benefits. What is Build N Build (BNB) Chain? BNB Chain is comprised of: BNB Beacon Chain ( previously Binance Chain ) - BNB Chain Governance (Staking, Voting) BNB Smart Chain (BSC) ( previously Binance Smart Chain ) - EVM compatible, consensus layers, and with hubs to multi-chains BNB Token BNB stands for \u201cBuild and Build\u201d . Along with fueling transactions on BNB Chain (similar to gas on Ethereum), BNB also acts as a governance token. Holding BNB gives you the right to make your voice heard and is necessary for participation in BNB Chain\u2019s decentralized on-chain governance. With this name change also comes more advancements to benefit users, projects and developers connected to the BNB Chain community. Over the past year, the BNB Chain community has made even further technical upgrades for progressive decentralization, including: Initiating the Bruno hard fork to increase the BNB burn rate. Key Features\u200b BSC 2021 (current version) introduces a considerable block size of 100m gas ceiling . We plan to introduce a more advanced logic for blockchain storage and BSC client to cover it and allow further expansion. Currently, to fully sync the BSC blockchain, validators need extensive storage and time. Scaling down the validator and node operator requirements is necessary to enable a seamless BSC experience. New technologies, like Erigon, are being verified to decrease both time and storage demands for validators nodes while performing full sync. Working with validators and infrastructure providers to deploy new solutions to address this issue, such as Parallel EVM Better block process pipeline Improved state caching Fast sync mode Distributed nodes 20 more validators to join the block production of BSC 2022 Future Goal Innovation never sleeps, and it\u2019s clear that the future of BNB Chain goes into a world of over 1 billion users. MetaFi is a key part of this too, helping to create a future where interoperability makes lives easier. BNB Chain\u2019s mission is to build the infrastructure that powers the world\u2019s parallel virtual ecosystem, and BNB Chain\u2019s commitment to the community is that it will be: Open Multi-chain For creators and inventors Permissionless Forever decentralized","title":"BNB Chain"},{"location":"#introduction","text":"BNB Chain, one of the most popular blockchains in the world, dedicates to delivering its core infrastructure necessary for future public adoption, and always remains as a community-first and open-source ecosystem built on a permissionless and decentralized environment. Binance Chain and Binance Smart Chain have formed together as BNB Chain since February 15, 2022. BNB Chain comprises BNB Beacon Chain (previously Binance Chain) and BNB Smart Chain (previously Binance Smart Chain). While BNB (formerly called \u201cBinance Coin\u201d) has also been renamed as \u201cBuild and Build.\u201d The name change is not merely for welcoming the crypto world with more than 1 billion users but also to strengthen the delivery of the core infrastructure necessary for future public adoption and, most importantly, to build a better ecosystem for embracing the MetaFi. MetaFi is a concept that provides advanced and sophisticated DeFi Infra to all the different types of projects such as metaverse, GameFi, SocialFi, Web3, and NFTs and puts them under one umbrella \u2013 MetaFi. This document will show the whole picture of the BNB Chain, how it works, and what it benefits.","title":"INTRODUCTION"},{"location":"#what-is-build-n-build-bnb-chain","text":"BNB Chain is comprised of: BNB Beacon Chain ( previously Binance Chain ) - BNB Chain Governance (Staking, Voting) BNB Smart Chain (BSC) ( previously Binance Smart Chain ) - EVM compatible, consensus layers, and with hubs to multi-chains","title":"What is Build N Build (BNB) Chain?"},{"location":"#bnb-token","text":"BNB stands for \u201cBuild and Build\u201d . Along with fueling transactions on BNB Chain (similar to gas on Ethereum), BNB also acts as a governance token. Holding BNB gives you the right to make your voice heard and is necessary for participation in BNB Chain\u2019s decentralized on-chain governance. With this name change also comes more advancements to benefit users, projects and developers connected to the BNB Chain community. Over the past year, the BNB Chain community has made even further technical upgrades for progressive decentralization, including: Initiating the Bruno hard fork to increase the BNB burn rate.","title":"BNB Token"},{"location":"#key-features","text":"BSC 2021 (current version) introduces a considerable block size of 100m gas ceiling . We plan to introduce a more advanced logic for blockchain storage and BSC client to cover it and allow further expansion. Currently, to fully sync the BSC blockchain, validators need extensive storage and time. Scaling down the validator and node operator requirements is necessary to enable a seamless BSC experience. New technologies, like Erigon, are being verified to decrease both time and storage demands for validators nodes while performing full sync. Working with validators and infrastructure providers to deploy new solutions to address this issue, such as Parallel EVM Better block process pipeline Improved state caching Fast sync mode Distributed nodes 20 more validators to join the block production of BSC 2022","title":"Key Features\u200b"},{"location":"#future-goal","text":"Innovation never sleeps, and it\u2019s clear that the future of BNB Chain goes into a world of over 1 billion users. MetaFi is a key part of this too, helping to create a future where interoperability makes lives easier. BNB Chain\u2019s mission is to build the infrastructure that powers the world\u2019s parallel virtual ecosystem, and BNB Chain\u2019s commitment to the community is that it will be: Open Multi-chain For creators and inventors Permissionless Forever decentralized","title":"Future Goal"},{"location":"BNBSmartChain/","text":"","title":"BNBSmartChain"},{"location":"BNBSmartChainCoreConcept/","text":"Consensus Engine of BNB Smart Chain Abstract \u200b We target to design the consensus engine of BSC(BNB Smart Chain) to achieve the following goals: Wait for a few blocks to confirm (should be less than Ethereum 1.0), better no fork in most cases. Blocking time should be shorter than Ethereum 1.0, i.e. 5 seconds or less. No inflation, the block reward is transaction gas fees. As much as compatible as Ethereum. With staking and governance as powerful as cosmos. Geth implements two kinds of consensus engines: ethash(based on PoW) and clique(based on PoA). Ethash is not a fit option for BSC because BSC gives up PoW. Clique has a shorter blocking time and is invulnerable to 51% attack while doing as little to the core data structure as possible to preserve existing Ethereum client compatibility. The shortcoming of PoA is centralization, and the lack of meaningful staking and governance capability on-chain. On the other hand, the Beacon Chain is built on Cosmos which does have a deployed staking and governance mechanism. Thus here we try to propose a consensus engine that: Beacon Chain does the staking and governance parts for BSC. ValidatorSet change, double sign slash of BSC is updated through interchain communication. Consensus engine of BSC keeps as simple as clique. We investigated some popular implementations of PoA consensus and found out that Bor follows a similar design as above. We will borrow a few parts from Bor and propose a new consensus engine to achieve all these goals. Infrastructure Components \u200b 1. Beacon Chain . It is responsible for holding the staking function to determine validators of BSC through an independent election, and the election workflow are performed via staking procedure. 2. BSC validators . Validators are responsible for validating transactions and generating blocks, ensuring the network\u2019s security and the consistency of the ledger. In return, they receive rewards from the gas consumption of transactions. 3. Staking dApps on BSC(also named as system contract) . There are several genesis contracts to help implement staking on BSC. Six classification groups of them: Light client contract. It is a watcher of distributed consensus process implemented by contract that only validates the consensus algorithm of Beacon Chain. Cross Chain Contract. It is the cross chain communication layer. It will verify the sequence and merkle proof of a cross chain package. BSCValidatorSet contract. It is a watcher of validators change of BSC on Beacon Chain. It will apply the validator set change for BSC. It also stores rewarded gas fee of blocking for validators, and distribute revenue to validators when receiving cross chain package of validatorSet change. System Reward contract. The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract. Liveness Slash Contract. The liveness of BSC relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. Other contracts. The BSC may take advantage of powerful governance of Beacon Chain, for example, propose to change a parameter of system contracts. Staking and Governance on Beacon Chain is at a higher layer upon consensus. As for Relayer, it is a standalone process and is open about how to implement it. The detail of them will not be included in this doc. This doc only focus on the BSC validators and Staking dApps on BSC parts which are more closely to consensus engine. System Reward Distribution\u200b The system reward structure in BSC is highly configurable. We may adjust the parameters through governance. The rewards comes from transaction fees, rewards are distributed based on several(configurable) rules: Validator that generate the block will receives 15/16 of the gas fee. System reward contract receive 1/16 of the gas fee. If the balance of System reward contract is above 100BNB, will not distribute any BNB to it. The coming section will explain how these contracts distributing reward. Staking dApps on BSC\u200b BSCValidatorSet contract \u200b It is a watcher of validators change of BSC on Beacon Chain. It implement the following interfaces: handleSynPackage(uint8, bytes calldata msgBytes) Conditions: 1. Message sender must CrossChainContract. Action: 1. if the first byte of msgBytes is 0x00, do Actions validators update; 2. if the first byte of msgBytes is 0x01, do Actions jail. Actions jail: 1. mark the validator as jailed. Actions validators update: 1. Do distribue the revenue of validators: if the revenue is large than 0.1 BNB, will do cross chain transfer to its account on BC, otherwise will transfer to its address on BSC. 2. Update the latest validatorSet. 3. Clean the metrics record on slash contract. CurrentValidator() returns ([]address) returns the the consensus address of not jailed validators. deposit(address valAddr) external Conditions: 1. The message sender must be the coinbase 2. Can only call once in one block. Actions: 1. Increase the revenue of the validator. System Reward contract \u200b For now, only Cross Chain contract is permitted to call system reward contract. It implement the following interfaces: claimRewards(address payable to, uint256 amount) external Conditions: 1. The message sender must in permission list. 2. The amount should be no more than 1 BNB Actions: 1. Transfer amount of BNB to specified address Liveness Slash contract \u200b If a validator failed to produce a block, will record it and finally slash it. It implement the following interfaces: Slash(validator address) external Conditions: 1. The message sender must in coinbase. 2. can only call once in one block. Actions: 1. increase the missing blocks metrics of the validator by one. 2. if the missing blocks metrics is times of 50, will call misdemeanor func of BSCValidatorSet contract to trigger a misdemeanor event and distribute the revenue of the validator to others. 3. if the missing blocks metrics is times of 150, will call felony func of BSCValidatorSet contract to trigger a felony event, not only distribute the revenue of the validator to others, but also kick the validator out of validatorset. Consensus Protocol\u200b The implement of the consensus engine is named as Parlia which is similar to clique . This doc will focus more on the difference and ignore the common details. Before introducing, we would like to clarify some terms: Epoch block. Consensus engine will update validatorSet from BSCValidatorSet contract periodly. For now the period is 200 blocks, a block is called epoch block if the height of it is times of 200. Snapshot. Snapshot is an assistant object that help to store the validators and recent signers of blocks. Key features \u200b Light client security \u200b Validators set changes take place at the (epoch+N/2) blocks. (N is the size of validatorset before epoch block). Considering the security of light client, we delay N/2 block to let validatorSet change take place. Every epoch block, validator will query the validatorset from contract and fill it in the extra_data field of block header. Full node will verify it against the validatorset in contract. A light client will use it as the validatorSet for next epoch blocks, however, it can not verify it against contract, it have to believe the signer of the epoch block. If the signer of the epoch block write a wrong extra_data, the light client may just go to a wrong chain. If we delay N/2 block to let validatorSet change take place, the wrong epoch block won\u2019t get another N/2 subsequent blocks that signed by other validators, so that the light client are free of such attack. System transaction \u200b The consensus engine may invoke system contracts, such transactions are called system transactions. System transactions is signed by the the validator who is producing the block. For the witness node, will generate the system transactions(without signature) according to its intrinsic logic and compare them with the system transactions in the block before applying them. Enforce backoff \u200b In Clique consensus protocol, out-of-turn validators have to wait a randomized amount of time before sealing the block. It is implemented in the client-side node software and works with the assumption that validators would run the canonical version. However, given that validators would be economically incentivized to seal blocks as soon as possible, it would be possible that the validators would run a modified version of the node software to ignore such a delay. To prevent validator rushing to seal a block, every out-turn validator will get a specified time slot to seal the block. Any block with a earlier blocking time produced by a out-turn validator will be discarded by other witness node. How to Produce a new block\u200b Step 1: Prepare \u200b A validator node prepares the block header of next block. Load snapshot from cache or database, If (height % epoch)==0, should fetch ValidatorSet from BSCValidatorSet contract. Every epoch block, will store validators set message in extraData field of block header to facilitate the implement of light client. The coinbase is the address of the validator Step2: FinalizeAndAssemble\u200b If the validator is not the in turn validator, will call liveness slash contract to slash the expected validator and generate a slashing transaction. If there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract. Step3: Seal \u200b The final step before a validator broadcast the new block. Sign all things in block header and append the signature to extraData. If it is out of turn for validators to sign blocks, an honest validator it will wait for a random reasonable time. How to Validate/Replay a block\u200b Step1: VerifyHeader\u200b Verify the block header when receiving a new block. Verify the signature of the coinbase is in extraData of the blockheader Compare the block time of the blockHeader and the expected block time that the signer suppose to use, will deny a blockerHeader that is smaller than expected. It helps to prevent a selfish validator from rushing to seal a block. The coinbase should be the signer and the difficulty should be expected value. Step2: Finalize \u200b If it is an epoch block, a validator node will fetch validatorSet from BSCValidatorSet and compare it with extra_data. If the block is not generate by inturn validatorvalidaror, will call slash contract. if there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract. The transaction generated by the consensus engine must be the same as the tx in block. Signature\u200b The signature of the coinbase is in extraData of the blockheader, the structure of extraData is: epoch block. 32 bytes of extraVanity + N*{20 bytes of validator address} + 65 bytes of signature. none epoch block. 32 bytes of extraVanity + 65 bytes of signature. The signed content is the Keccak256 of RLP encoded of the block header. Security and Finality\u200b Given there are more than 1/2 N+1 validators are honest, PoA based networks usually work securely and properly. However, there are still cases where certain amount Byzantine validators may still manage to attack the network, e.g. through the \u201cClone Attack\u201d. To secure as much as BC, BSC users are encouraged to wait until receiving blocks sealed by more than 2/3 N+1 different validators. In that way, the BSC can be trusted at a similar security level to BC and can tolerate less than 1/3*N Byzantine validators. With 21 validators, if the block time is 5 seconds, the 2/3 N+1 different validator seals will need a time period of (2/3 21+1) 5 = 75 seconds. Any critical applications for BSC may have to wait for 2/3 N+1 to ensure a relatively secure finality. However, besides such an arrangement, BSC does introduce Slashing logic to penalize Byzantine validators for double signing or instability. This Slashing logic will expose the malicious validators in a very short time and make the Clone Attack very hard or extremely non-economic to execute. With this enhancement, 1/2*N+1 or even fewer blocks are enough as confirmation for most transactions. Potential Issue\u200b Extending the ruling of the current validator set via temporary censorship \u200b If the transaction that updates the validator is sent to the BSC right on the epoch period, then it is possible for the in-turn validator to censor the transaction and not change the set of validators for that epoch. While a transaction cannot be forever censored without the help of other n/2 validators, by this it can extend the time of the current validator set and gain some rewards. In general, the probability of this scheme can increase by colluding with other validators. It is relatively benign issue that a block may be approximately 5 secs and one epoch being 240 blocks, i.e. 20 mins so the validators could only be extended for another 20 mins.","title":"BNB(SC)Core Concept"},{"location":"BNBSmartChainCoreConcept/#consensus-engine-of-bnb-smart-chain","text":"","title":"Consensus Engine of BNB Smart Chain"},{"location":"BNBSmartChainCoreConcept/#abstract","text":"\u200b We target to design the consensus engine of BSC(BNB Smart Chain) to achieve the following goals: Wait for a few blocks to confirm (should be less than Ethereum 1.0), better no fork in most cases. Blocking time should be shorter than Ethereum 1.0, i.e. 5 seconds or less. No inflation, the block reward is transaction gas fees. As much as compatible as Ethereum. With staking and governance as powerful as cosmos. Geth implements two kinds of consensus engines: ethash(based on PoW) and clique(based on PoA). Ethash is not a fit option for BSC because BSC gives up PoW. Clique has a shorter blocking time and is invulnerable to 51% attack while doing as little to the core data structure as possible to preserve existing Ethereum client compatibility. The shortcoming of PoA is centralization, and the lack of meaningful staking and governance capability on-chain. On the other hand, the Beacon Chain is built on Cosmos which does have a deployed staking and governance mechanism. Thus here we try to propose a consensus engine that: Beacon Chain does the staking and governance parts for BSC. ValidatorSet change, double sign slash of BSC is updated through interchain communication. Consensus engine of BSC keeps as simple as clique. We investigated some popular implementations of PoA consensus and found out that Bor follows a similar design as above. We will borrow a few parts from Bor and propose a new consensus engine to achieve all these goals.","title":"Abstract"},{"location":"BNBSmartChainCoreConcept/#infrastructure-components","text":"\u200b 1. Beacon Chain . It is responsible for holding the staking function to determine validators of BSC through an independent election, and the election workflow are performed via staking procedure. 2. BSC validators . Validators are responsible for validating transactions and generating blocks, ensuring the network\u2019s security and the consistency of the ledger. In return, they receive rewards from the gas consumption of transactions. 3. Staking dApps on BSC(also named as system contract) . There are several genesis contracts to help implement staking on BSC. Six classification groups of them: Light client contract. It is a watcher of distributed consensus process implemented by contract that only validates the consensus algorithm of Beacon Chain. Cross Chain Contract. It is the cross chain communication layer. It will verify the sequence and merkle proof of a cross chain package. BSCValidatorSet contract. It is a watcher of validators change of BSC on Beacon Chain. It will apply the validator set change for BSC. It also stores rewarded gas fee of blocking for validators, and distribute revenue to validators when receiving cross chain package of validatorSet change. System Reward contract. The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract. Liveness Slash Contract. The liveness of BSC relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. Other contracts. The BSC may take advantage of powerful governance of Beacon Chain, for example, propose to change a parameter of system contracts. Staking and Governance on Beacon Chain is at a higher layer upon consensus. As for Relayer, it is a standalone process and is open about how to implement it. The detail of them will not be included in this doc. This doc only focus on the BSC validators and Staking dApps on BSC parts which are more closely to consensus engine.","title":"Infrastructure Components"},{"location":"BNBSmartChainCoreConcept/#system-reward-distribution","text":"The system reward structure in BSC is highly configurable. We may adjust the parameters through governance. The rewards comes from transaction fees, rewards are distributed based on several(configurable) rules: Validator that generate the block will receives 15/16 of the gas fee. System reward contract receive 1/16 of the gas fee. If the balance of System reward contract is above 100BNB, will not distribute any BNB to it. The coming section will explain how these contracts distributing reward.","title":"System Reward Distribution\u200b"},{"location":"BNBSmartChainCoreConcept/#staking-dapps-on-bsc","text":"","title":"Staking dApps on BSC\u200b"},{"location":"BNBSmartChainCoreConcept/#bscvalidatorset-contract","text":"\u200b It is a watcher of validators change of BSC on Beacon Chain. It implement the following interfaces: handleSynPackage(uint8, bytes calldata msgBytes)","title":"BSCValidatorSet contract"},{"location":"BNBSmartChainCoreConcept/#conditions","text":"1. Message sender must CrossChainContract.","title":"Conditions:"},{"location":"BNBSmartChainCoreConcept/#action","text":"1. if the first byte of msgBytes is 0x00, do Actions validators update; 2. if the first byte of msgBytes is 0x01, do Actions jail.","title":"Action:"},{"location":"BNBSmartChainCoreConcept/#actions-jail","text":"1. mark the validator as jailed.","title":"Actions jail:"},{"location":"BNBSmartChainCoreConcept/#actions-validators-update","text":"1. Do distribue the revenue of validators: if the revenue is large than 0.1 BNB, will do cross chain transfer to its account on BC, otherwise will transfer to its address on BSC. 2. Update the latest validatorSet. 3. Clean the metrics record on slash contract.","title":"Actions validators update:"},{"location":"BNBSmartChainCoreConcept/#currentvalidator-returns-address","text":"returns the the consensus address of not jailed validators.","title":"CurrentValidator() returns ([]address)"},{"location":"BNBSmartChainCoreConcept/#depositaddress-valaddr-external","text":"","title":"deposit(address valAddr) external"},{"location":"BNBSmartChainCoreConcept/#conditions_1","text":"1. The message sender must be the coinbase 2. Can only call once in one block.","title":"Conditions:"},{"location":"BNBSmartChainCoreConcept/#actions","text":"1. Increase the revenue of the validator.","title":"Actions:"},{"location":"BNBSmartChainCoreConcept/#system-reward-contract","text":"\u200b For now, only Cross Chain contract is permitted to call system reward contract. It implement the following interfaces: claimRewards(address payable to, uint256 amount) external","title":"System Reward contract"},{"location":"BNBSmartChainCoreConcept/#conditions_2","text":"1. The message sender must in permission list. 2. The amount should be no more than 1 BNB","title":"Conditions:"},{"location":"BNBSmartChainCoreConcept/#actions_1","text":"1. Transfer amount of BNB to specified address","title":"Actions:"},{"location":"BNBSmartChainCoreConcept/#liveness-slash-contract","text":"\u200b If a validator failed to produce a block, will record it and finally slash it. It implement the following interfaces: Slash(validator address) external","title":"Liveness Slash contract"},{"location":"BNBSmartChainCoreConcept/#conditions_3","text":"1. The message sender must in coinbase. 2. can only call once in one block.","title":"Conditions:"},{"location":"BNBSmartChainCoreConcept/#actions_2","text":"1. increase the missing blocks metrics of the validator by one. 2. if the missing blocks metrics is times of 50, will call misdemeanor func of BSCValidatorSet contract to trigger a misdemeanor event and distribute the revenue of the validator to others. 3. if the missing blocks metrics is times of 150, will call felony func of BSCValidatorSet contract to trigger a felony event, not only distribute the revenue of the validator to others, but also kick the validator out of validatorset.","title":"Actions:"},{"location":"BNBSmartChainCoreConcept/#consensus-protocol","text":"The implement of the consensus engine is named as Parlia which is similar to clique . This doc will focus more on the difference and ignore the common details. Before introducing, we would like to clarify some terms: Epoch block. Consensus engine will update validatorSet from BSCValidatorSet contract periodly. For now the period is 200 blocks, a block is called epoch block if the height of it is times of 200. Snapshot. Snapshot is an assistant object that help to store the validators and recent signers of blocks.","title":"Consensus Protocol\u200b"},{"location":"BNBSmartChainCoreConcept/#key-features","text":"\u200b","title":"Key features"},{"location":"BNBSmartChainCoreConcept/#light-client-security","text":"Validators set changes take place at the (epoch+N/2) blocks. (N is the size of validatorset before epoch block). Considering the security of light client, we delay N/2 block to let validatorSet change take place. Every epoch block, validator will query the validatorset from contract and fill it in the extra_data field of block header. Full node will verify it against the validatorset in contract. A light client will use it as the validatorSet for next epoch blocks, however, it can not verify it against contract, it have to believe the signer of the epoch block. If the signer of the epoch block write a wrong extra_data, the light client may just go to a wrong chain. If we delay N/2 block to let validatorSet change take place, the wrong epoch block won\u2019t get another N/2 subsequent blocks that signed by other validators, so that the light client are free of such attack.","title":"Light client security\u200b"},{"location":"BNBSmartChainCoreConcept/#system-transaction","text":"The consensus engine may invoke system contracts, such transactions are called system transactions. System transactions is signed by the the validator who is producing the block. For the witness node, will generate the system transactions(without signature) according to its intrinsic logic and compare them with the system transactions in the block before applying them.","title":"System transaction\u200b"},{"location":"BNBSmartChainCoreConcept/#enforce-backoff","text":"In Clique consensus protocol, out-of-turn validators have to wait a randomized amount of time before sealing the block. It is implemented in the client-side node software and works with the assumption that validators would run the canonical version. However, given that validators would be economically incentivized to seal blocks as soon as possible, it would be possible that the validators would run a modified version of the node software to ignore such a delay. To prevent validator rushing to seal a block, every out-turn validator will get a specified time slot to seal the block. Any block with a earlier blocking time produced by a out-turn validator will be discarded by other witness node.","title":"Enforce backoff\u200b"},{"location":"BNBSmartChainCoreConcept/#how-to-produce-a-new-block","text":"","title":"How to Produce a new block\u200b"},{"location":"BNBSmartChainCoreConcept/#step-1-prepare","text":"A validator node prepares the block header of next block. Load snapshot from cache or database, If (height % epoch)==0, should fetch ValidatorSet from BSCValidatorSet contract. Every epoch block, will store validators set message in extraData field of block header to facilitate the implement of light client. The coinbase is the address of the validator","title":"Step 1: Prepare\u200b"},{"location":"BNBSmartChainCoreConcept/#step2-finalizeandassemble","text":"If the validator is not the in turn validator, will call liveness slash contract to slash the expected validator and generate a slashing transaction. If there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract.","title":"Step2: FinalizeAndAssemble\u200b"},{"location":"BNBSmartChainCoreConcept/#step3-seal","text":"The final step before a validator broadcast the new block. Sign all things in block header and append the signature to extraData. If it is out of turn for validators to sign blocks, an honest validator it will wait for a random reasonable time.","title":"Step3: Seal\u200b"},{"location":"BNBSmartChainCoreConcept/#how-to-validatereplay-a-block","text":"","title":"How to Validate/Replay a block\u200b"},{"location":"BNBSmartChainCoreConcept/#step1-verifyheader","text":"Verify the block header when receiving a new block. Verify the signature of the coinbase is in extraData of the blockheader Compare the block time of the blockHeader and the expected block time that the signer suppose to use, will deny a blockerHeader that is smaller than expected. It helps to prevent a selfish validator from rushing to seal a block. The coinbase should be the signer and the difficulty should be expected value.","title":"Step1: VerifyHeader\u200b"},{"location":"BNBSmartChainCoreConcept/#step2-finalize","text":"If it is an epoch block, a validator node will fetch validatorSet from BSCValidatorSet and compare it with extra_data. If the block is not generate by inturn validatorvalidaror, will call slash contract. if there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract. The transaction generated by the consensus engine must be the same as the tx in block.","title":"Step2: Finalize\u200b"},{"location":"BNBSmartChainCoreConcept/#signature","text":"The signature of the coinbase is in extraData of the blockheader, the structure of extraData is: epoch block. 32 bytes of extraVanity + N*{20 bytes of validator address} + 65 bytes of signature. none epoch block. 32 bytes of extraVanity + 65 bytes of signature. The signed content is the Keccak256 of RLP encoded of the block header.","title":"Signature\u200b"},{"location":"BNBSmartChainCoreConcept/#security-and-finality","text":"Given there are more than 1/2 N+1 validators are honest, PoA based networks usually work securely and properly. However, there are still cases where certain amount Byzantine validators may still manage to attack the network, e.g. through the \u201cClone Attack\u201d. To secure as much as BC, BSC users are encouraged to wait until receiving blocks sealed by more than 2/3 N+1 different validators. In that way, the BSC can be trusted at a similar security level to BC and can tolerate less than 1/3*N Byzantine validators. With 21 validators, if the block time is 5 seconds, the 2/3 N+1 different validator seals will need a time period of (2/3 21+1) 5 = 75 seconds. Any critical applications for BSC may have to wait for 2/3 N+1 to ensure a relatively secure finality. However, besides such an arrangement, BSC does introduce Slashing logic to penalize Byzantine validators for double signing or instability. This Slashing logic will expose the malicious validators in a very short time and make the Clone Attack very hard or extremely non-economic to execute. With this enhancement, 1/2*N+1 or even fewer blocks are enough as confirmation for most transactions.","title":"Security and Finality\u200b"},{"location":"BNBSmartChainCoreConcept/#potential-issue","text":"Extending the ruling of the current validator set via temporary censorship \u200b If the transaction that updates the validator is sent to the BSC right on the epoch period, then it is possible for the in-turn validator to censor the transaction and not change the set of validators for that epoch. While a transaction cannot be forever censored without the help of other n/2 validators, by this it can extend the time of the current validator set and gain some rewards. In general, the probability of this scheme can increase by colluding with other validators. It is relatively benign issue that a block may be approximately 5 secs and one epoch being 240 blocks, i.e. 20 mins so the validators could only be extended for another 20 mins.","title":"Potential Issue\u200b"},{"location":"BNBSmartChainIntro/","text":"Introduction BNB Smart Chain is an innovative solution to bring programmability and interoperability to Beacon Chain. BNB Smart Chain relies on a system of 21 active validators with Proof of Staked Authority (PoSA) consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. Other than the 21 active validators, BSC will introduce more validators, e.g. another 20 inactive validators, into the validator set as backups, which will be called \u201cCandidates\u201d. Candidates will produce blocks and charge gas fees in BSC mainnet, but in a much less chance than the official validator set of 21 elected. The unavailable candidates will be slashed as well though in a smaller size. A decent motivation is expected to be maintained so that the candidate validators are willing to ensure the quality and help secure BSC. In an extreme case, if a majority of the active 21 validators get attacked and offline, Candidate Validators can report to Beacon Chain about the stale blocking, resume it and eventually propose a re-election of the active validator set. The BNB Smart Chain also supports EVM-compatible smart contracts and protocols. Cross-chain transfer and other communication are possible due to native support of interoperability. Binance DEX remains a liquid venue of the exchange of assets on both chains. This dual-chain architecture will be ideal for users to take advantage of the fast trading on one side and build their decentralized apps on the other side. The Binance Smart Chain will be: A self-sovereign blockchain: Provides security and safety with elected validators . EVM-compatible: Supports all the existing Ethereum tooling along with faster - finality and cheaper transaction fees. Interoperable: Comes with efficient native dual chain communication; Optimized for scaling high-performance dApps that require a fast and smooth user experience. Distributed with on-chain governance: Proof of Staked Authority (PoSA) brings in decentralization and community participants. As the native token, BNB will serve as both the gas of smart contract execution and tokens for staking. Ecosystem of cross-chains and multi-chains\u200b The big lesson learned from BSC 2021 is that \u201cone chain\u201d cannot cover all angles. At the peak time, BSC had more than 2M daily active users (DAU), with a single GameFi reaching up to 1M DAU. This introduced significant challenges for both the network itself and its supporting infrastructure like RPC/API nodes. For dApps with massive user bases, multi-chains and cross-chain should be the solution. The BSC Core Team strongly believes in partition chains and a multi-chain future as it can sustain the ever-increasing demand for decentralized computing power and storage. This is consistent with many other blockchains in the industry, such as ETH2.0 and multi-chain strategies in Polkadot, Cosmos, and Avalanche. The cross-shard and cross-chain/multi-chain interoperability will be the key topic of 2022. The BSC validators and developers community is dedicated to fulfilling BSC\u2019s vision to operate at the crossroads of a decentralized blockchain future. Specifically, we aim to achieve this by implementing new technologies on BSC via BSC Application Side Chain (BAS) and BSC Partition Chain (BPC) infrastructure layers. BSC Application Side Chain (BAS)\u200b The BAS is an infrastructure introduced to help developers and node operators build and run their own blockchain as their internal value system for a massive number of users while still maintaining a close connection with BSC. Any project developer will be able to deploy their own BAS with its unique specifications and validator set. This validator set can run with fewer validators than BSC, depending on the BAS deployer. These validators can be run by the application owners or any community stakeholders, bringing more flexibility and decentralization to BAS. The typical usage of BAS is like the Ronin chain for the Axie Infinity. However, to minimize the potential risks of the side chain, a new protocol (including built-in asset types and cross-chain) should be introduced to ensure seamless liquidity between BAS and BSC. BSC Partition Chain (BPC)\u200b The BPC will introduce another subspace with a new validator set, a new computing engine, and a new ledger. Essentially it works as a \u201cshard\u201d or a \u201clayer 2\u201d to offload part of the data, computing, and transactions from the BSC Mainnet to other smaller parallel blockchains. BPC will be a PoSA based blockchain like BSC. Anyone can become a validator for one or more particular BPC on Beacon Chain, which will serve as the beacon chain. The validators can call for delegation to be elected into the validator set of BPC. The election could work on the same principles as the validator elections on BSC \u2013 validators are elected every 24 hours based on their staking power (staked BNB). Deployment of BPCs will decrease the number of data stored by dividing it across multiple BPC blockchains. Resources\u200b WhitePaper","title":"BNBSmartChain"},{"location":"BNBSmartChainIntro/#introduction","text":"BNB Smart Chain is an innovative solution to bring programmability and interoperability to Beacon Chain. BNB Smart Chain relies on a system of 21 active validators with Proof of Staked Authority (PoSA) consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. Other than the 21 active validators, BSC will introduce more validators, e.g. another 20 inactive validators, into the validator set as backups, which will be called \u201cCandidates\u201d. Candidates will produce blocks and charge gas fees in BSC mainnet, but in a much less chance than the official validator set of 21 elected. The unavailable candidates will be slashed as well though in a smaller size. A decent motivation is expected to be maintained so that the candidate validators are willing to ensure the quality and help secure BSC. In an extreme case, if a majority of the active 21 validators get attacked and offline, Candidate Validators can report to Beacon Chain about the stale blocking, resume it and eventually propose a re-election of the active validator set. The BNB Smart Chain also supports EVM-compatible smart contracts and protocols. Cross-chain transfer and other communication are possible due to native support of interoperability. Binance DEX remains a liquid venue of the exchange of assets on both chains. This dual-chain architecture will be ideal for users to take advantage of the fast trading on one side and build their decentralized apps on the other side. The Binance Smart Chain will be: A self-sovereign blockchain: Provides security and safety with elected validators . EVM-compatible: Supports all the existing Ethereum tooling along with faster - finality and cheaper transaction fees. Interoperable: Comes with efficient native dual chain communication; Optimized for scaling high-performance dApps that require a fast and smooth user experience. Distributed with on-chain governance: Proof of Staked Authority (PoSA) brings in decentralization and community participants. As the native token, BNB will serve as both the gas of smart contract execution and tokens for staking.","title":"Introduction"},{"location":"BNBSmartChainIntro/#ecosystem-of-cross-chains-and-multi-chains","text":"The big lesson learned from BSC 2021 is that \u201cone chain\u201d cannot cover all angles. At the peak time, BSC had more than 2M daily active users (DAU), with a single GameFi reaching up to 1M DAU. This introduced significant challenges for both the network itself and its supporting infrastructure like RPC/API nodes. For dApps with massive user bases, multi-chains and cross-chain should be the solution. The BSC Core Team strongly believes in partition chains and a multi-chain future as it can sustain the ever-increasing demand for decentralized computing power and storage. This is consistent with many other blockchains in the industry, such as ETH2.0 and multi-chain strategies in Polkadot, Cosmos, and Avalanche. The cross-shard and cross-chain/multi-chain interoperability will be the key topic of 2022. The BSC validators and developers community is dedicated to fulfilling BSC\u2019s vision to operate at the crossroads of a decentralized blockchain future. Specifically, we aim to achieve this by implementing new technologies on BSC via BSC Application Side Chain (BAS) and BSC Partition Chain (BPC) infrastructure layers.","title":"Ecosystem of cross-chains and multi-chains\u200b"},{"location":"BNBSmartChainIntro/#bsc-application-side-chain-bas","text":"The BAS is an infrastructure introduced to help developers and node operators build and run their own blockchain as their internal value system for a massive number of users while still maintaining a close connection with BSC. Any project developer will be able to deploy their own BAS with its unique specifications and validator set. This validator set can run with fewer validators than BSC, depending on the BAS deployer. These validators can be run by the application owners or any community stakeholders, bringing more flexibility and decentralization to BAS. The typical usage of BAS is like the Ronin chain for the Axie Infinity. However, to minimize the potential risks of the side chain, a new protocol (including built-in asset types and cross-chain) should be introduced to ensure seamless liquidity between BAS and BSC.","title":"BSC Application Side Chain (BAS)\u200b"},{"location":"BNBSmartChainIntro/#bsc-partition-chain-bpc","text":"The BPC will introduce another subspace with a new validator set, a new computing engine, and a new ledger. Essentially it works as a \u201cshard\u201d or a \u201clayer 2\u201d to offload part of the data, computing, and transactions from the BSC Mainnet to other smaller parallel blockchains. BPC will be a PoSA based blockchain like BSC. Anyone can become a validator for one or more particular BPC on Beacon Chain, which will serve as the beacon chain. The validators can call for delegation to be elected into the validator set of BPC. The election could work on the same principles as the validator elections on BSC \u2013 validators are elected every 24 hours based on their staking power (staked BNB). Deployment of BPCs will decrease the number of data stored by dividing it across multiple BPC blockchains.","title":"BSC Partition Chain (BPC)\u200b"},{"location":"BNBSmartChainIntro/#resources","text":"WhitePaper","title":"Resources\u200b"},{"location":"BSCApplicationSide/","text":"About BSC Application Side Chain (BAS) Why is BAS introduced?\u200b To overcome network scalability problems of BSC in 2021, the BSC community has proposed the use of BAS in their Outlook 2022 paper. These sidechains can be designed for much higher throughput and lower (even zero) gas fees. We want to define a protocol for consensus management and messaging between BAS and BSC so that it is easier for developers to use a ready-made solution and it is easier for BSC to integrate with them. Briefly speaking, the typical usage of BAS is like that of the Ronin chain for the Axie Infinity on Ethereum. However, unlike Ronin, BAS is designed with better architecture and security in mind. The idea of BAS is to allow you to expand and reuse existing modules, and by using the architecture on smart contracts, painlessly modify existing contracts. What is BAS?\u200b BAS (BNB Application Side-Chain) is a framework for creating sidechains in the BSC (BNB Smart Chain) ecosystem. It is an infrastructure to help developers and node operators build and run their own blockchains as their internal value system and for a massive number of users while still maintaining a close connection with the BSC. The main task of BAS is to facilitate any project developer to be able to deploy their own blockchains with their unique specifications and validator set but still be connected to the BSC infrastructure. The validator set can run with fewer validators than BNB Chain, depending on the BAS deployer. These validators can be run by the application owners or any community stakeholders, bringing more flexibility and decentralization to BAS. We can rightfully claim that BAS is a lightweight framework on which one can build simple but functional blockchain projects. Developers and teams can create simple blockchains with their own business rules and economies. Most importantly, they can extend the existing functionality of the BNB Chain (BSC). Architecture\u200b BAS is a modular framework for creating BSC-compatible sidechains. It defines requirements for integration with the BSC ecosystem and brings development-ready EVM-compatible features like staking, RPC-API, and smart contracts. Since BSC doesn\u2019t rely on the BAS security model, there is no default embedded production-ready bridge solution between the BSC and BAS networks. Instead, BAS can provide protocols and standards for integrating third-party bridges that can be managed by the BAS validator set of other projects like Celer Network\u2019s cBridge or Multichain. Technically, BAS is a set of smart contracts written in any possible programming language. The contract executor itself can be anyone and work in any way; BAS does not require the use of any specific set of programming languages or API standards. In essence, BAS defines the primary structure and configuration of the blockchain, using special templates. A template is a ready-made blockchain solution that is already integrated into the BSC infrastructure. With this integration, developers automatically get access to such useful products as a ready-made staking system, block explorer, SDK, API gateways, interfaces for governance, etc. The current implementation of BAS is based on a modified version of BSC, but this is not the rule, BAS can technically run on top of any blockchain. In the future, the list of templates will be extended. For more details, please refer to Ankr documentation . How to Launch a BAS?\u200b To launch a BAS, follow these steps defined in Ankr documentation . Celer has also provided a testnet BAS bridge . If you want to setup your own testnet, you can reach NodeReal Support or Ankr to get professional support there. Testnets\u200b There are two testnets where you can try BAS. It already contains pre-deployed API gateways, block explorer, UI for the staking, and a faucet. Ankr Testnet: Ankr documentation . NodeReal Testnet: NodeReal Testnet blog and documentation . FAQ\u200b For more questions, refer to Ankr documentation .","title":"BSCApplicationSideChain"},{"location":"BSCApplicationSide/#about-bsc-application-side-chain-bas","text":"","title":"About BSC Application Side Chain (BAS)"},{"location":"BSCApplicationSide/#why-is-bas-introduced","text":"To overcome network scalability problems of BSC in 2021, the BSC community has proposed the use of BAS in their Outlook 2022 paper. These sidechains can be designed for much higher throughput and lower (even zero) gas fees. We want to define a protocol for consensus management and messaging between BAS and BSC so that it is easier for developers to use a ready-made solution and it is easier for BSC to integrate with them. Briefly speaking, the typical usage of BAS is like that of the Ronin chain for the Axie Infinity on Ethereum. However, unlike Ronin, BAS is designed with better architecture and security in mind. The idea of BAS is to allow you to expand and reuse existing modules, and by using the architecture on smart contracts, painlessly modify existing contracts.","title":"Why is BAS introduced?\u200b"},{"location":"BSCApplicationSide/#what-is-bas","text":"BAS (BNB Application Side-Chain) is a framework for creating sidechains in the BSC (BNB Smart Chain) ecosystem. It is an infrastructure to help developers and node operators build and run their own blockchains as their internal value system and for a massive number of users while still maintaining a close connection with the BSC. The main task of BAS is to facilitate any project developer to be able to deploy their own blockchains with their unique specifications and validator set but still be connected to the BSC infrastructure. The validator set can run with fewer validators than BNB Chain, depending on the BAS deployer. These validators can be run by the application owners or any community stakeholders, bringing more flexibility and decentralization to BAS. We can rightfully claim that BAS is a lightweight framework on which one can build simple but functional blockchain projects. Developers and teams can create simple blockchains with their own business rules and economies. Most importantly, they can extend the existing functionality of the BNB Chain (BSC).","title":"What is BAS?\u200b"},{"location":"BSCApplicationSide/#architecture","text":"BAS is a modular framework for creating BSC-compatible sidechains. It defines requirements for integration with the BSC ecosystem and brings development-ready EVM-compatible features like staking, RPC-API, and smart contracts. Since BSC doesn\u2019t rely on the BAS security model, there is no default embedded production-ready bridge solution between the BSC and BAS networks. Instead, BAS can provide protocols and standards for integrating third-party bridges that can be managed by the BAS validator set of other projects like Celer Network\u2019s cBridge or Multichain. Technically, BAS is a set of smart contracts written in any possible programming language. The contract executor itself can be anyone and work in any way; BAS does not require the use of any specific set of programming languages or API standards. In essence, BAS defines the primary structure and configuration of the blockchain, using special templates. A template is a ready-made blockchain solution that is already integrated into the BSC infrastructure. With this integration, developers automatically get access to such useful products as a ready-made staking system, block explorer, SDK, API gateways, interfaces for governance, etc. The current implementation of BAS is based on a modified version of BSC, but this is not the rule, BAS can technically run on top of any blockchain. In the future, the list of templates will be extended. For more details, please refer to Ankr documentation .","title":"Architecture\u200b"},{"location":"BSCApplicationSide/#how-to-launch-a-bas","text":"To launch a BAS, follow these steps defined in Ankr documentation . Celer has also provided a testnet BAS bridge . If you want to setup your own testnet, you can reach NodeReal Support or Ankr to get professional support there.","title":"How to Launch a BAS?\u200b"},{"location":"BSCApplicationSide/#testnets","text":"There are two testnets where you can try BAS. It already contains pre-deployed API gateways, block explorer, UI for the staking, and a faucet. Ankr Testnet: Ankr documentation . NodeReal Testnet: NodeReal Testnet blog and documentation .","title":"Testnets\u200b"},{"location":"BSCApplicationSide/#faq","text":"For more questions, refer to Ankr documentation .","title":"FAQ\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/","text":"Architecture Cross-Chain Communication A native cross chain communication protocol is developed between BC (Beacon Chain) and BSC (BNB Smart Chain). It has the following key parts: Build-in System Contract Oracle on Beacon Chain BSC Relayer BSC Relayer Incentive Mechanism Oracle Relayer Architecture Diagram\u200b The following diagram depicts the architecture of the cross-transfer mechanism. Build-in System Contract Disclaimer \u200b The software and related documentation are under active development, all subject to potential future change without notification and not ready for production use. The code and security audit have not been fully completed and are not ready for any bug bounty. We advise you to be careful and experiment on the network at your own risk. Stay safe out there. GitHub Implementation link: https://github.com/bnb-chain/bsc-genesis-contract Contract Name Contract Address ABI file BSCValidatorSet Contract 0x0000000000000000000000000000000000001000 bscvalidatorset Liveness Slash Contract 0x0000000000000000000000000000000000001001 slashindicator SystemReward Contract 0x0000000000000000000000000000000000001002 systemreward TendermintLightClient Contract 0x0000000000000000000000000000000000001003 tendermintlightclient TokenHub Contract 0x0000000000000000000000000000000000001004 tokenhub RelayerIncentivize Contract 0x0000000000000000000000000000000000001005 relayerincentivize RelayerHub Contract 0x0000000000000000000000000000000000001006 relayerhub GovHub Contract 0x0000000000000000000000000000000000001007 govhub TokenManager Contract 0x0000000000000000000000000000000000001008 tokenmanager CrossChain Contract 0x0000000000000000000000000000000000002000 crosschain On-Chain Light Client \u200b The purpose of cross-chain interoperability is to enable one blockchain to function as a light-client of another. Since Beacon Chain is using a classical Byzantine Fault Tolerant consensus algorithm, light-client verification is cheap and easy: all we have to do is check validator signatures on the latest block, and verify a Merkle proof of the state. In Tendermint, validators agree on a block before processing it. This means that the signatures and state root for that block aren't included until the next block. Thus, each block contains a field called LastCommit, which contains the votes responsible for committing the previous block, and a field in the block header called AppHash, which refers to the Merkle root hash of the application after processing the transactions from the previous block. So, if we want to verify the AppHash from height H, we need the signatures from LastCommit at height H+1. (And remember that this AppHash only contains the results from all transactions up to and including block H-1) Unlike Proof-of-Work, the light-client protocol does not need to download and check all the headers in the blockchain - the client can always jump straight to the latest header available, so long as the validator set has not changed much. If the validator set is changing, the client needs to track these changes, which requires downloading headers for each block in which there is a significant change. Here, we will assume the validator set is constant, and postpone handling validator set changes for another time. Ethereum platform supports stateless precompiled contract implemented with golang and normal contract implemented with solidity. As compared to normal contracts, precompiled contracts are more efficient and costs less gas, but they are stateless. However, on-chain light client must be stateful. So here we will try to a mixed approach: precompiled implemented contract(stateless calculation, such as signature verification) and normal contract (store validator set and trusted appHash). Precompile Contract\u200b Validate Tendermint Header\u200b This contract implements tendermint header verification algorithm. The input parameters contain the trusted consensus state and a new tendermint header. The validation algorithm will verify the new tendermint header against the trusted consensus state. If the new header is valid, a new consensus state will be created and returned to caller. Otherwise, an error will be returned. Validate Merkle Proof\u200b This contract implements a Tendermint merkle proof verification algorithm . Solidity Contract \u200b Ten*dermint Light Client Contract\u200b ConsensusState: The first consensus state will be written in the constructor. Once a new tendermint header is verified, a new consensus state will be created. type ConsensusState struct { chainID string height int64 appHash []byte curValidatorSetHash []byte nextValidatorSet *tmtypes.ValidatorSet } Tendermint Header: A relayer who want to sync new tendermint headers need to query BC to build this object. Then encode it to byte array and call syncTendermintHeader. type Header struct { Header blockHeader Validator[] CurValidatorSet Validator[] NextValidatorSet } This contract implements the following four methods: function syncTendermintHeader (byte[] header, uint64 height) syncTendermintHeader gets nearest consensus state by height and call validateTendermintHeader in precompiled contract to verify the tendermint header. If the success, a new consensus state will be saved. function getAppHash (uint64 height) returns(bytes32) getAppHash provides a method to get the verified appHash at the specified height. Besides, If the header of the specified height have not be verified, then zero value will be returned. function isHeaderSynced (uint64 height) returns (bool) isHeaderSynced provides a lower cost method to judge if the specified height has been synced. function getSubmitter (uint64 height) returns (address) getSubmitter provides a method to get the submitter address of the specified header. Merkle Proof Verification Library\u200b This library provides an util to verify merkle proof from BC. Contracts which need to verify Merkle proof just need to import this library. function verifyMerkleProof (int64 height, byte[] key, byte[] value, byte[] proof) bool verifyMerkleProof reassembles user parameters and calls the above precompiled contract to validate the proof. Other Build-in System Contract\u200b TokenHub Contract This contract focuses on cross chain token transfer. TokenManager Contract This contract focuses on binding and unbinding tokens on two chains. BSCValidatorSet Contract It is a watcher of validators change of BSC on Beacon Chain. It will interact with light client contracts to verify the interchain transaction, and apply the validator set change for BSC. It also stores rewarded gas fee of blocking for validators, and distribute it to validators when receiving cross chain package of validatorSet change. System Reward Contract The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract. Liveness Slash Contract The liveness of BSC relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. BscValidatorSet Contract This contract focuses on handling staking change package from BC. It also provides the validatorset data query for BSC consensus engine. RelayerHub Contract This contract manages the authority of bsc-relayer. Someone who wants to run a bsc-relayer must call the contract to deposit some BNB to get the authorization. Governance Contract This contract handles the governance package from BC. The governance package contains the target contract address, parameter name and new parameter value. Once the package is verified, this contract will call the parameter update method of the target contract to update the parameter to new value. Cross Chain Contract This contract focuses on cross chain packages pretreatment and sending cross chain packages to BC by emit event. The packages pretreatment includes sequence validation and the merkle proof verification. Once they are passed, the package will be routed to application build-in system contract, such as tokenhub or bscvalidator. Besides, if tokenhub or bscvalidator wants to send packages to BC, they need to encode their packages with rlp and call this contract to send them. Cross-Chain Transfer Token Transfer Cross-chain transfers only support bound BEP2 or BEP8 tokens on BC and BEP20 tokens on BSC. Verify Token Info\u200b First, you should make sure that it's already bound. For example, you could see the binding info of BNB : ## mainnet bnbcli token info --symbol BNB --trust-node --node http://dataseed4.binance.org:80 ## testnet tbnbcli token info --symbol BNB --trust-node --node http://data-seed-pre-0-s3.binance.org:80 { \"type\": \"bnbchain/Token\", \"value\": { \"name\": \"Binance Chain Native Token\", \"symbol\": \"BNB\", \"original_symbol\": \"BNB\", \"total_supply\": \"200000000.00000000\", \"owner\": \"tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy\", \"mintable\": false, \"contract_address\": \"0x0000000000000000000000000000000000000000\", \"contract_decimals\": 18 } } As BNB is the native token on both chains, so we use 0x0000000000000000000000000000000000000000 as the corresponding contract address. Besides, on BSC, the native token decimals is 18, while the decimals on BC is 8. So if you transfer 1e8:BNB to BSC, the recipient balance will gain 1e18. Transfer BNB from BC to BSC\u200b Example: ## mainnet bnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Tigris --from owner --amount 100000000:BNB --node http://dataseed4.binance.org:80 ## testnet tbnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Ganges --from owner --amount 100000000:BNB --node http://data-seed-pre-0-s3.binance.org:80 Result: Committed at block 465899 (tx hash: 68FFF82197E27A3EC14AFF8C99A035FA9CA7120312AA55E98D11DFC0F8D9F3B9, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Events:[{Type: Attributes:[{Key:[84 114 97 110 115 102 101 114 79 117 116 83 101 113 117 101 110 99 101] Value:[49 49] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[69 120 112 105 114 101 84 105 109 101] Value:[49 53 57 55 53 52 51 49 57 51] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 114 111 115 115 84 114 97 110 115 102 101 114 79 117 116] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) Transfer BNB from BSC to BC\u200b transferOut\u200b Call transferOut of TokenHub contract in MyEtherWallet : Parameter Name Type Description contractAddr address for BNB, the value must be 0x0000000000000000000000000000000000000000 recipient address decode bech32 address, starting with 0x . To transfer to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 The BNB decimals on BSC is 18. If you want to transfer one BNB, then the value should be 1e18. Besides, the value must be N * 1e10 expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (amount + RelayFee)/1e18 RelayFee should be 0.01BNB and it can be updated by on-chain governance. For example, if you transfer 1BNB from BSC to BC, the value should be at least 1.01BNB. After all the above parameters have been set to proper values, users can click the transact button to build transactions, and metamask plugin will be ejected. Then users can click the confirm button in metamask to sign and broadcast transactions. batchTransferOutBNB\u200b Call batchTransferOutBNB of TokenHub contract in MyEtherWallet: Parameter Name Type Description recipientAddrs address[] decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/0 amounts uint256[] amount for each recipient, should be N * 1e10 refundAddrs address[] sender can specify some address as the refund address if the cross chain transfer is failed. expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (sumOfAmounts + RelayFee * batchSize)/1e18 Transfer BEP2 to BSC\u200b Execute the following command to transfer ABC-A64 token to BSC: ## mainnet bnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Tigris --from owner --amount 10000000000:ABC-A64 --node http://dataseed4.binance.org:80 ## testnet tbnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Ganges --from owner --amount 10000000000:ABC-A64 --node http://data-seed-pre-0-s3.binance.org:80 Transfer BEP20 to BC\u200b Before calling transferOut * or batchTransferOut , users need to call approve method to grant enough allowance to TokenHub contract. For transferOut method, the allowance should equal the transfer amount. For batchTransferOut**, the allowance should be the sum of the amount array. transferOut \u200b Parameter Name Type Description contractAddr address BEP20 contract address recipient address decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 BEP20 token amount. Here the decimals is 18, so the amount must be N * 1e10. expireTime uint256 Timestamp, counted by second The value here should be RelayFee. Mint\u200b If both the BEP20 token and bep2 token are mintable, then token owners can still mint their tokens even after token binding. Besides, token owners need to ensure the total supply and the locked amount on both chains are still matched, otherwise, users might can\u2019t transfer their tokens to another chain. Mint token on BC\u200b 1. Execute the following command to mint 10000 ABC-A64: ## mainnet bnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Tigris --node http://dataseed4.binance.org:80 ## testnet tbnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Ganges --node http://data-seed-pre-0-s3.binance.org:80 Mint token on BSC and lock the new minted token: Call mint method of BEP20 contract, the mint amount should be 1e22. Transfer all minted ABC token to tokenHub contract: 0x0000000000000000000000000000000000001004 Mint token on BSC\u200b 1. Call mint of BEP20 contract to mint 10000 ABC, the mint amount should be 1e22(18 decimals). Mint token on BC and lock the new minted token: Execute the following command to mint 10000 ABC-A64: ## mainnet bnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Tigris --node http://dataseed4.binance.org:80 ## testnet tbnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Ganges --node http://data-seed-pre-0-s3.binance.org:80 Transfer all minted ABC-A64 token to the pure-code-controlled address: tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr (mainnet address: bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj ) BSC Relayer Relayers are responsible for submitting Cross-Chain Communication Packages between the two blockchains. Due to the heterogeneous parallel chain structure, two different types of Relayers are created. Relayers for BC-to-BSC communication referred to as BSC Relayers are a standalone process that can be run by anyone, and anywhere, except that Relayers must register themselves onto BSC and deposit a certain amount of BNB. Only relaying requests from the registered Relayers will be accepted by BSC. GitHub Implementation link: https://github.com/bnb-chain/bsc-relayer Config Files: https://github.com/bnb-chain/bsc-relayer-config Monitor and Parse Cross Chain Event\u200b As a BSC relayer, it must have proper configurations on the following three items: Name Type Description srcCrossChainID uint16 CrossChainID of BC, the value is 1 for testnet destCrossChainID uint16 CrossChainID of BSC, the value is 96 for testnet A BSC relayer is required to parse all block results and pick out all events with event type \u201cIBCPackage\u201d from endBlock event table. This is an cross chain package event example: { \"type\": \"IBCPackage\", \"attributes\": [ { \"key\": \"IBCPackageInfo\", \"value\": \"96::8::19\" } ] } BSC relayer should iterate all the attributes and parse the attribute value: Split the value with \u201c::\u201d and get a 4-length string array Follow the following table to parse the 4 elements: Index Description Type Example Value 0 CrossChainID of destination chain int16 96 1 channel id int8 8 2 sequence int64 19 Filter out attributes with mismatched destination chain CrossChainID. Build Tendermint Header and Query Cross Chain Package\u200b Build Tendermint Header\u200b import tmtypes \"github.com/tendermint/tendermint/types\" type Header struct { tmtypes.SignedHeader ValidatorSet *tmtypes.ValidatorSet `json:\"validator_set\"` NextValidatorSet *tmtypes.ValidatorSet `json:\"next_validator_set\"` } If a cross chain package event is found at height H , wait for block H+1 and call the following rpc methods to build the above Header object: Name Method tmtypes.SignedHeader {rpcEndpoint}/commit?height=H+1 ValidatorSet {rpcEndpoint}/validators?height=H+1 NextValidatorSet {rpcEndpoint}/validators?height=H+2 Header Encoding in golang: Add dependency on go-amino v0.14.1 Add dependency on tendermint v0.32.3 : Example golang code to encode Header : import ( amino \"github.com/tendermint/go-amino\" tmtypes \"github.com/tendermint/tendermint/types\" ) var cdc = amino.NewCodec() func init() { tmtypes.RegisterBlockAmino(cdc) } func EncodeHeader(h *Header) ([]byte, error) { bz, err := cdc.MarshalBinaryLengthPrefixed(h) if err != nil { return nil, err } return bz, nil } Query Cross Chain Package With Merkle Proof\u200b Query height: H Query path: /store/ibc/key Follow the table to build a 14-length byte array as query key: Name Length Value prefix 1 bytes 0x00 source chain CrossChainID 2 bytes srcCrossChainID in bsc relayer configuration destination chain CrossChainID 2 bytes destCrossChainID in bsc relayer configuration channelID 1 bytes channelID from event attribute sequence 8 bytes sequence from event attribute Assemble the above parameters to the following rpc call. {rpcEndpoint}/abci_query?path={queryPath}&data={queryKey}&height={queryHeight}&prove=true Call Build-In System Contract\u200b Sync BC Header\u200b function syncTendermintHeader (bytes calldata header, uint64 height) Call syncTendermintHeader of TendermintLightClient contract to sync BC header. The contract address is 0x0000000000000000000000000000000000001003. The \u201cheader\u201d is the encoding result of Header and the height should be H+1 Deliver Cross Chain Package\u200b Call handlePackage of crosschain contract(0x0000000000000000000000000000000000002000) to deliver the cross chain packages: Parameter Name Type Value msgBytes []byte package bytes proof []byte merkle proof bytes height uint64 H+1 packageSequence uint64 sequence from attribution value channelId uint64 channle id Incentive Mechanism for BSC Relayer The BSC relayers play an important role in relaying interchain packages from BC to BSC. All BSC relayers build their stable infrastructure, watch any event happened on the Beacon Chain, and act timely to get paid accordingly. The following discussion is about how to distribute the rewards to let the relayers are willing to make a long-term contribution. Principle\u200b Considering the following points: Fairness, competitiveness, and redundancy: Everyone has a chance to run a relayer even on cheap hardware. It should be hard for someone to get all the rewards. Simplicity. Robustness: The relayer may have a strategy to make its largest profit accordingly, under any condition, the interchain communication should not be blocked. Low Risk: The relayer should take a little risk to play in this game. For the top N relayers, they should gain enough rewards to cover the cost. It is tough hard to achieve all these goals; we make some trade-off on robustness and low risk in the following design. Rewards Source and Allocation\u200b We have three reward sources: Users paid rewards: Users who send bind or cross chain transfer transactions need to pay extra fee as BSC relayer rewards. System rewards: Rewards comes from SystemReward contract. The role of relayers and their rewards comes from: Relayer Behavior Rewards come from User packages(bind, unbind, transfer) from BC to BSC Users pay for the reward System packages(staking, slash, governance) from BC to BSC System reward Relayer for sync tendermint header to light client contract System reward Rewards Distribution Formula\u200b To prevent the relayer who has the best network always winning the game, we gather the reward into two reward pools (header relayer reward pool and package relayer reward pool) and reallocate to the relayers to achieve redundancy: S is a constant number of transactions that in around. Each round, there are S transactions, and the last transaction of the round will trigger reward distribution. N is the maximum weight that a relayer can gain in a round. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i. Weight formula for package relayers:\u200b Rp represents the total balance of package reward pool. Weight formula for header relayers:\u200b Rh represents the total balance of header reward pool. We consider setting these parameters a reasonable value: \u200b 1. S to be 100. Some rewards come from gas fee, we can not guarantee enough rewards during a small round, a large round may dismiss deviation and let relayer give up relaying when it has made its max profit. 2. N to be 40. We think the redundancy of relayer around 3-5 is best. If N is too large, the redundancy will decrease. If N is too small, then there will not be enough relayers. Set N as 40 may be a reasonable value, at least 3 relayers can compete. 3. The relayFee of a single package and the ratio of reward for header relayer can be modified by governance on Beacon Chain. Distribution And Claim Reward\u200b In each round, the last package delivery transaction will trigger the reward distribution. Both the header reward pool and package reward pool will be distributed. However, the reward won't be paid directly to relayer accounts. The distribution algorithm just calculates rewards for all relayers and writes down the amounts. Relayers are required to actively send transactions to claim their own accumulated rewards. Other Consideration\u200b System Reward Pool\u200b The system reward pool can hold at most 100BNB for example, to prevent the pool get unnecessary income. The client needs to query the balance of the contract to decide whether to distribute 1/16 of the transaction fee to the contract or not. It seems not that fair that some validators pay more to the reward pool than others, but this is random and will eventually become fair in the long run. If there are not enough rewards in the pool, all the tokens in the pool will be distributed. Block header sync transaction with validatorSet change will claim reward to relayers from system reward pool directly. Foul Play\u200b For example, a relayer may deliver packages using a different address in round robin, we can\u2019t recognize this. We try to introduce registration and BNB deposit for relayer to raise the cost of cheat. How it works: A BSC account needs to call the register of RelayerHub contract to deposit 100BNB(more or less than 100 BNB will be rejected) to become a BSC relayer. Only a valid relayer can sync Beacon Chain Headers and deliver cross-chain packages. Relayer can withdraw its deposit, but we will charge 0.1 BNB as the transaction fee so that it will receive 99.9 BNB back. The charged fee will directly go to the system reward pool. Oracle Module The oracle module is a common module like gov which is used to handle prophecy and claim. Prophecy means the validators want to reach a consensus on something, like cross chain transfer. Claim is raised by a validator and the content of claim is the cross chain transfer. When most of the validators (like 70%) claim the same thing on the prophecy, the winning claim will be executed.For oracle module is a common module, other module which depends on oracle module will register claim type and related hooks checking and handling claim. Each claim type has a sequence, oracle module should process prophecy and claim by sequence. When one prophecy is executed successfully, the sequence of the claim type will be increased by one. Oracle Process\u200b Oracle module receives a claim message from validator, if the sequence is not current sequence, the claim message will be rejected. If sequence is valid, the hooks of the claim type will check the claim message, if the claim message is invalid, then return If the claim message is valid and it\u2019s the first claim, the related prophecy will be created. If claim message is not the first claim, then it will be added to the existed prophecy. If the power of validators which claim the same content reaches a threshold like 70%, the prophecy will be marked success and the hooks will execute the winning claim and the sequence of claim type will be increased. If there is no chance that the validators will reach a consensus, the prophecy will be marked failed and the prophecy will be deleted and the validators should start over again. Bridge Module\u200b Bridge module will process cross chain transactions. It contains two parts: transactions from BC to BSC and transactions from BSC to BC. For transactions from BSC to BC, it will depend on the oracle module. When the validators reach a consensus on a certain claim, the bridge module will process the transaction according to the claim, like transfer from BSC to BC. For transactions from BC to BSC, it will process the BC part of the transaction and write the related cross chain package for BSC. Oracle Relayer The relayer is a service which monitors events on BSC, builds and broadcasts transactions to BC. Each validator operator should maintain its own relayer service. The relayer service requires to have access to the validator operator private key. All relayer service independently witness the peggy contract events, then build transactions to claim events to BC oracle module. The relay process: Continually listen for cross chain event Parse the cross-chain transfer parameters from event data Use this information to build an unsigned BC oracle transaction Sign and broadcast transaction. GitHub Implementation link: https://github.com/bnb-chain/oracle-relayer","title":"BC AND BSC Cross-Chain Mechanism"},{"location":"Binance%20Cross-Chain%20Mechanism/#architecture","text":"","title":"Architecture"},{"location":"Binance%20Cross-Chain%20Mechanism/#cross-chain-communication","text":"A native cross chain communication protocol is developed between BC (Beacon Chain) and BSC (BNB Smart Chain). It has the following key parts: Build-in System Contract Oracle on Beacon Chain BSC Relayer BSC Relayer Incentive Mechanism Oracle Relayer","title":"Cross-Chain Communication"},{"location":"Binance%20Cross-Chain%20Mechanism/#architecture-diagram","text":"The following diagram depicts the architecture of the cross-transfer mechanism.","title":"Architecture Diagram\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#build-in-system-contract","text":"","title":"Build-in System Contract"},{"location":"Binance%20Cross-Chain%20Mechanism/#disclaimer","text":"\u200b The software and related documentation are under active development, all subject to potential future change without notification and not ready for production use. The code and security audit have not been fully completed and are not ready for any bug bounty. We advise you to be careful and experiment on the network at your own risk. Stay safe out there. GitHub Implementation link: https://github.com/bnb-chain/bsc-genesis-contract Contract Name Contract Address ABI file BSCValidatorSet Contract 0x0000000000000000000000000000000000001000 bscvalidatorset Liveness Slash Contract 0x0000000000000000000000000000000000001001 slashindicator SystemReward Contract 0x0000000000000000000000000000000000001002 systemreward TendermintLightClient Contract 0x0000000000000000000000000000000000001003 tendermintlightclient TokenHub Contract 0x0000000000000000000000000000000000001004 tokenhub RelayerIncentivize Contract 0x0000000000000000000000000000000000001005 relayerincentivize RelayerHub Contract 0x0000000000000000000000000000000000001006 relayerhub GovHub Contract 0x0000000000000000000000000000000000001007 govhub TokenManager Contract 0x0000000000000000000000000000000000001008 tokenmanager CrossChain Contract 0x0000000000000000000000000000000000002000 crosschain","title":"Disclaimer"},{"location":"Binance%20Cross-Chain%20Mechanism/#on-chain-light-client","text":"\u200b The purpose of cross-chain interoperability is to enable one blockchain to function as a light-client of another. Since Beacon Chain is using a classical Byzantine Fault Tolerant consensus algorithm, light-client verification is cheap and easy: all we have to do is check validator signatures on the latest block, and verify a Merkle proof of the state. In Tendermint, validators agree on a block before processing it. This means that the signatures and state root for that block aren't included until the next block. Thus, each block contains a field called LastCommit, which contains the votes responsible for committing the previous block, and a field in the block header called AppHash, which refers to the Merkle root hash of the application after processing the transactions from the previous block. So, if we want to verify the AppHash from height H, we need the signatures from LastCommit at height H+1. (And remember that this AppHash only contains the results from all transactions up to and including block H-1) Unlike Proof-of-Work, the light-client protocol does not need to download and check all the headers in the blockchain - the client can always jump straight to the latest header available, so long as the validator set has not changed much. If the validator set is changing, the client needs to track these changes, which requires downloading headers for each block in which there is a significant change. Here, we will assume the validator set is constant, and postpone handling validator set changes for another time. Ethereum platform supports stateless precompiled contract implemented with golang and normal contract implemented with solidity. As compared to normal contracts, precompiled contracts are more efficient and costs less gas, but they are stateless. However, on-chain light client must be stateful. So here we will try to a mixed approach: precompiled implemented contract(stateless calculation, such as signature verification) and normal contract (store validator set and trusted appHash).","title":"On-Chain Light Client"},{"location":"Binance%20Cross-Chain%20Mechanism/#precompile-contract","text":"Validate Tendermint Header\u200b This contract implements tendermint header verification algorithm. The input parameters contain the trusted consensus state and a new tendermint header. The validation algorithm will verify the new tendermint header against the trusted consensus state. If the new header is valid, a new consensus state will be created and returned to caller. Otherwise, an error will be returned. Validate Merkle Proof\u200b This contract implements a Tendermint merkle proof verification algorithm .","title":"Precompile Contract\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#solidity-contract","text":"\u200b Ten*dermint Light Client Contract\u200b ConsensusState: The first consensus state will be written in the constructor. Once a new tendermint header is verified, a new consensus state will be created. type ConsensusState struct { chainID string height int64 appHash []byte curValidatorSetHash []byte nextValidatorSet *tmtypes.ValidatorSet } Tendermint Header: A relayer who want to sync new tendermint headers need to query BC to build this object. Then encode it to byte array and call syncTendermintHeader. type Header struct { Header blockHeader Validator[] CurValidatorSet Validator[] NextValidatorSet } This contract implements the following four methods: function syncTendermintHeader (byte[] header, uint64 height) syncTendermintHeader gets nearest consensus state by height and call validateTendermintHeader in precompiled contract to verify the tendermint header. If the success, a new consensus state will be saved. function getAppHash (uint64 height) returns(bytes32) getAppHash provides a method to get the verified appHash at the specified height. Besides, If the header of the specified height have not be verified, then zero value will be returned. function isHeaderSynced (uint64 height) returns (bool) isHeaderSynced provides a lower cost method to judge if the specified height has been synced. function getSubmitter (uint64 height) returns (address) getSubmitter provides a method to get the submitter address of the specified header. Merkle Proof Verification Library\u200b This library provides an util to verify merkle proof from BC. Contracts which need to verify Merkle proof just need to import this library. function verifyMerkleProof (int64 height, byte[] key, byte[] value, byte[] proof) bool verifyMerkleProof reassembles user parameters and calls the above precompiled contract to validate the proof.","title":"Solidity Contract"},{"location":"Binance%20Cross-Chain%20Mechanism/#other-build-in-system-contract","text":"TokenHub Contract This contract focuses on cross chain token transfer. TokenManager Contract This contract focuses on binding and unbinding tokens on two chains. BSCValidatorSet Contract It is a watcher of validators change of BSC on Beacon Chain. It will interact with light client contracts to verify the interchain transaction, and apply the validator set change for BSC. It also stores rewarded gas fee of blocking for validators, and distribute it to validators when receiving cross chain package of validatorSet change. System Reward Contract The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract. Liveness Slash Contract The liveness of BSC relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. BscValidatorSet Contract This contract focuses on handling staking change package from BC. It also provides the validatorset data query for BSC consensus engine. RelayerHub Contract This contract manages the authority of bsc-relayer. Someone who wants to run a bsc-relayer must call the contract to deposit some BNB to get the authorization. Governance Contract This contract handles the governance package from BC. The governance package contains the target contract address, parameter name and new parameter value. Once the package is verified, this contract will call the parameter update method of the target contract to update the parameter to new value. Cross Chain Contract This contract focuses on cross chain packages pretreatment and sending cross chain packages to BC by emit event. The packages pretreatment includes sequence validation and the merkle proof verification. Once they are passed, the package will be routed to application build-in system contract, such as tokenhub or bscvalidator. Besides, if tokenhub or bscvalidator wants to send packages to BC, they need to encode their packages with rlp and call this contract to send them.","title":"Other Build-in System Contract\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#cross-chain-transfer-token-transfer","text":"Cross-chain transfers only support bound BEP2 or BEP8 tokens on BC and BEP20 tokens on BSC.","title":"Cross-Chain Transfer Token Transfer"},{"location":"Binance%20Cross-Chain%20Mechanism/#verify-token-info","text":"First, you should make sure that it's already bound. For example, you could see the binding info of BNB : ## mainnet bnbcli token info --symbol BNB --trust-node --node http://dataseed4.binance.org:80 ## testnet tbnbcli token info --symbol BNB --trust-node --node http://data-seed-pre-0-s3.binance.org:80 { \"type\": \"bnbchain/Token\", \"value\": { \"name\": \"Binance Chain Native Token\", \"symbol\": \"BNB\", \"original_symbol\": \"BNB\", \"total_supply\": \"200000000.00000000\", \"owner\": \"tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy\", \"mintable\": false, \"contract_address\": \"0x0000000000000000000000000000000000000000\", \"contract_decimals\": 18 } } As BNB is the native token on both chains, so we use 0x0000000000000000000000000000000000000000 as the corresponding contract address. Besides, on BSC, the native token decimals is 18, while the decimals on BC is 8. So if you transfer 1e8:BNB to BSC, the recipient balance will gain 1e18.","title":"Verify Token Info\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#transfer-bnb-from-bc-to-bsc","text":"Example: ## mainnet bnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Tigris --from owner --amount 100000000:BNB --node http://dataseed4.binance.org:80 ## testnet tbnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Ganges --from owner --amount 100000000:BNB --node http://data-seed-pre-0-s3.binance.org:80 Result: Committed at block 465899 (tx hash: 68FFF82197E27A3EC14AFF8C99A035FA9CA7120312AA55E98D11DFC0F8D9F3B9, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Events:[{Type: Attributes:[{Key:[84 114 97 110 115 102 101 114 79 117 116 83 101 113 117 101 110 99 101] Value:[49 49] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[69 120 112 105 114 101 84 105 109 101] Value:[49 53 57 55 53 52 51 49 57 51] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 114 111 115 115 84 114 97 110 115 102 101 114 79 117 116] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0})","title":"Transfer BNB from BC to BSC\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#transfer-bnb-from-bsc-to-bc","text":"","title":"Transfer BNB from BSC to BC\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#transferout","text":"Call transferOut of TokenHub contract in MyEtherWallet : Parameter Name Type Description contractAddr address for BNB, the value must be 0x0000000000000000000000000000000000000000 recipient address decode bech32 address, starting with 0x . To transfer to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 The BNB decimals on BSC is 18. If you want to transfer one BNB, then the value should be 1e18. Besides, the value must be N * 1e10 expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (amount + RelayFee)/1e18 RelayFee should be 0.01BNB and it can be updated by on-chain governance. For example, if you transfer 1BNB from BSC to BC, the value should be at least 1.01BNB. After all the above parameters have been set to proper values, users can click the transact button to build transactions, and metamask plugin will be ejected. Then users can click the confirm button in metamask to sign and broadcast transactions.","title":"transferOut\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#batchtransferoutbnb","text":"Call batchTransferOutBNB of TokenHub contract in MyEtherWallet: Parameter Name Type Description recipientAddrs address[] decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/0 amounts uint256[] amount for each recipient, should be N * 1e10 refundAddrs address[] sender can specify some address as the refund address if the cross chain transfer is failed. expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (sumOfAmounts + RelayFee * batchSize)/1e18","title":"batchTransferOutBNB\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#transfer-bep2-to-bsc","text":"Execute the following command to transfer ABC-A64 token to BSC: ## mainnet bnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Tigris --from owner --amount 10000000000:ABC-A64 --node http://dataseed4.binance.org:80 ## testnet tbnbcli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id Binance-Chain-Ganges --from owner --amount 10000000000:ABC-A64 --node http://data-seed-pre-0-s3.binance.org:80","title":"Transfer BEP2 to BSC\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#transfer-bep20-to-bc","text":"Before calling transferOut * or batchTransferOut , users need to call approve method to grant enough allowance to TokenHub contract. For transferOut method, the allowance should equal the transfer amount. For batchTransferOut**, the allowance should be the sum of the amount array.","title":"Transfer BEP20 to BC\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#transferout_1","text":"\u200b Parameter Name Type Description contractAddr address BEP20 contract address recipient address decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 BEP20 token amount. Here the decimals is 18, so the amount must be N * 1e10. expireTime uint256 Timestamp, counted by second The value here should be RelayFee.","title":"transferOut"},{"location":"Binance%20Cross-Chain%20Mechanism/#mint","text":"If both the BEP20 token and bep2 token are mintable, then token owners can still mint their tokens even after token binding. Besides, token owners need to ensure the total supply and the locked amount on both chains are still matched, otherwise, users might can\u2019t transfer their tokens to another chain. Mint token on BC\u200b 1. Execute the following command to mint 10000 ABC-A64: ## mainnet bnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Tigris --node http://dataseed4.binance.org:80 ## testnet tbnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Ganges --node http://data-seed-pre-0-s3.binance.org:80 Mint token on BSC and lock the new minted token: Call mint method of BEP20 contract, the mint amount should be 1e22. Transfer all minted ABC token to tokenHub contract: 0x0000000000000000000000000000000000001004 Mint token on BSC\u200b 1. Call mint of BEP20 contract to mint 10000 ABC, the mint amount should be 1e22(18 decimals). Mint token on BC and lock the new minted token: Execute the following command to mint 10000 ABC-A64: ## mainnet bnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Tigris --node http://dataseed4.binance.org:80 ## testnet tbnbcli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id Binance-Chain-Ganges --node http://data-seed-pre-0-s3.binance.org:80 Transfer all minted ABC-A64 token to the pure-code-controlled address: tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr (mainnet address: bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj )","title":"Mint\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#bsc-relayer","text":"Relayers are responsible for submitting Cross-Chain Communication Packages between the two blockchains. Due to the heterogeneous parallel chain structure, two different types of Relayers are created. Relayers for BC-to-BSC communication referred to as BSC Relayers are a standalone process that can be run by anyone, and anywhere, except that Relayers must register themselves onto BSC and deposit a certain amount of BNB. Only relaying requests from the registered Relayers will be accepted by BSC. GitHub Implementation link: https://github.com/bnb-chain/bsc-relayer Config Files: https://github.com/bnb-chain/bsc-relayer-config","title":"BSC Relayer"},{"location":"Binance%20Cross-Chain%20Mechanism/#monitor-and-parse-cross-chain-event","text":"As a BSC relayer, it must have proper configurations on the following three items: Name Type Description srcCrossChainID uint16 CrossChainID of BC, the value is 1 for testnet destCrossChainID uint16 CrossChainID of BSC, the value is 96 for testnet A BSC relayer is required to parse all block results and pick out all events with event type \u201cIBCPackage\u201d from endBlock event table. This is an cross chain package event example: { \"type\": \"IBCPackage\", \"attributes\": [ { \"key\": \"IBCPackageInfo\", \"value\": \"96::8::19\" } ] } BSC relayer should iterate all the attributes and parse the attribute value: Split the value with \u201c::\u201d and get a 4-length string array Follow the following table to parse the 4 elements: Index Description Type Example Value 0 CrossChainID of destination chain int16 96 1 channel id int8 8 2 sequence int64 19 Filter out attributes with mismatched destination chain CrossChainID.","title":"Monitor and Parse Cross Chain Event\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#build-tendermint-header-and-query-cross-chain-package","text":"Build Tendermint Header\u200b import tmtypes \"github.com/tendermint/tendermint/types\" type Header struct { tmtypes.SignedHeader ValidatorSet *tmtypes.ValidatorSet `json:\"validator_set\"` NextValidatorSet *tmtypes.ValidatorSet `json:\"next_validator_set\"` } If a cross chain package event is found at height H , wait for block H+1 and call the following rpc methods to build the above Header object: Name Method tmtypes.SignedHeader {rpcEndpoint}/commit?height=H+1 ValidatorSet {rpcEndpoint}/validators?height=H+1 NextValidatorSet {rpcEndpoint}/validators?height=H+2 Header Encoding in golang: Add dependency on go-amino v0.14.1 Add dependency on tendermint v0.32.3 : Example golang code to encode Header : import ( amino \"github.com/tendermint/go-amino\" tmtypes \"github.com/tendermint/tendermint/types\" ) var cdc = amino.NewCodec() func init() { tmtypes.RegisterBlockAmino(cdc) } func EncodeHeader(h *Header) ([]byte, error) { bz, err := cdc.MarshalBinaryLengthPrefixed(h) if err != nil { return nil, err } return bz, nil }","title":"Build Tendermint Header and Query Cross Chain Package\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#query-cross-chain-package-with-merkle-proof","text":"Query height: H Query path: /store/ibc/key Follow the table to build a 14-length byte array as query key: Name Length Value prefix 1 bytes 0x00 source chain CrossChainID 2 bytes srcCrossChainID in bsc relayer configuration destination chain CrossChainID 2 bytes destCrossChainID in bsc relayer configuration channelID 1 bytes channelID from event attribute sequence 8 bytes sequence from event attribute Assemble the above parameters to the following rpc call. {rpcEndpoint}/abci_query?path={queryPath}&data={queryKey}&height={queryHeight}&prove=true","title":"Query Cross Chain Package With Merkle Proof\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#call-build-in-system-contract","text":"","title":"Call Build-In System Contract\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#sync-bc-header","text":"function syncTendermintHeader (bytes calldata header, uint64 height) Call syncTendermintHeader of TendermintLightClient contract to sync BC header. The contract address is 0x0000000000000000000000000000000000001003. The \u201cheader\u201d is the encoding result of Header and the height should be H+1","title":"Sync BC Header\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#deliver-cross-chain-package","text":"Call handlePackage of crosschain contract(0x0000000000000000000000000000000000002000) to deliver the cross chain packages: Parameter Name Type Value msgBytes []byte package bytes proof []byte merkle proof bytes height uint64 H+1 packageSequence uint64 sequence from attribution value channelId uint64 channle id","title":"Deliver Cross Chain Package\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#incentive-mechanism-for-bsc-relayer","text":"The BSC relayers play an important role in relaying interchain packages from BC to BSC. All BSC relayers build their stable infrastructure, watch any event happened on the Beacon Chain, and act timely to get paid accordingly. The following discussion is about how to distribute the rewards to let the relayers are willing to make a long-term contribution.","title":"Incentive Mechanism for BSC Relayer"},{"location":"Binance%20Cross-Chain%20Mechanism/#principle","text":"Considering the following points: Fairness, competitiveness, and redundancy: Everyone has a chance to run a relayer even on cheap hardware. It should be hard for someone to get all the rewards. Simplicity. Robustness: The relayer may have a strategy to make its largest profit accordingly, under any condition, the interchain communication should not be blocked. Low Risk: The relayer should take a little risk to play in this game. For the top N relayers, they should gain enough rewards to cover the cost. It is tough hard to achieve all these goals; we make some trade-off on robustness and low risk in the following design.","title":"Principle\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#rewards-source-and-allocation","text":"We have three reward sources: Users paid rewards: Users who send bind or cross chain transfer transactions need to pay extra fee as BSC relayer rewards. System rewards: Rewards comes from SystemReward contract. The role of relayers and their rewards comes from: Relayer Behavior Rewards come from User packages(bind, unbind, transfer) from BC to BSC Users pay for the reward System packages(staking, slash, governance) from BC to BSC System reward Relayer for sync tendermint header to light client contract System reward","title":"Rewards Source and Allocation\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#rewards-distribution-formula","text":"To prevent the relayer who has the best network always winning the game, we gather the reward into two reward pools (header relayer reward pool and package relayer reward pool) and reallocate to the relayers to achieve redundancy: S is a constant number of transactions that in around. Each round, there are S transactions, and the last transaction of the round will trigger reward distribution. N is the maximum weight that a relayer can gain in a round. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i.","title":"Rewards Distribution Formula\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#weight-formula-for-package-relayers","text":"Rp represents the total balance of package reward pool.","title":"Weight formula for package relayers:\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#weight-formula-for-header-relayers","text":"Rh represents the total balance of header reward pool. We consider setting these parameters a reasonable value: \u200b 1. S to be 100. Some rewards come from gas fee, we can not guarantee enough rewards during a small round, a large round may dismiss deviation and let relayer give up relaying when it has made its max profit. 2. N to be 40. We think the redundancy of relayer around 3-5 is best. If N is too large, the redundancy will decrease. If N is too small, then there will not be enough relayers. Set N as 40 may be a reasonable value, at least 3 relayers can compete. 3. The relayFee of a single package and the ratio of reward for header relayer can be modified by governance on Beacon Chain. Distribution And Claim Reward\u200b In each round, the last package delivery transaction will trigger the reward distribution. Both the header reward pool and package reward pool will be distributed. However, the reward won't be paid directly to relayer accounts. The distribution algorithm just calculates rewards for all relayers and writes down the amounts. Relayers are required to actively send transactions to claim their own accumulated rewards.","title":"Weight formula for header relayers:\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#other-consideration","text":"System Reward Pool\u200b The system reward pool can hold at most 100BNB for example, to prevent the pool get unnecessary income. The client needs to query the balance of the contract to decide whether to distribute 1/16 of the transaction fee to the contract or not. It seems not that fair that some validators pay more to the reward pool than others, but this is random and will eventually become fair in the long run. If there are not enough rewards in the pool, all the tokens in the pool will be distributed. Block header sync transaction with validatorSet change will claim reward to relayers from system reward pool directly. Foul Play\u200b For example, a relayer may deliver packages using a different address in round robin, we can\u2019t recognize this. We try to introduce registration and BNB deposit for relayer to raise the cost of cheat. How it works: A BSC account needs to call the register of RelayerHub contract to deposit 100BNB(more or less than 100 BNB will be rejected) to become a BSC relayer. Only a valid relayer can sync Beacon Chain Headers and deliver cross-chain packages. Relayer can withdraw its deposit, but we will charge 0.1 BNB as the transaction fee so that it will receive 99.9 BNB back. The charged fee will directly go to the system reward pool.","title":"Other Consideration\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#oracle-module","text":"The oracle module is a common module like gov which is used to handle prophecy and claim. Prophecy means the validators want to reach a consensus on something, like cross chain transfer. Claim is raised by a validator and the content of claim is the cross chain transfer. When most of the validators (like 70%) claim the same thing on the prophecy, the winning claim will be executed.For oracle module is a common module, other module which depends on oracle module will register claim type and related hooks checking and handling claim. Each claim type has a sequence, oracle module should process prophecy and claim by sequence. When one prophecy is executed successfully, the sequence of the claim type will be increased by one.","title":"Oracle Module"},{"location":"Binance%20Cross-Chain%20Mechanism/#oracle-process","text":"Oracle module receives a claim message from validator, if the sequence is not current sequence, the claim message will be rejected. If sequence is valid, the hooks of the claim type will check the claim message, if the claim message is invalid, then return If the claim message is valid and it\u2019s the first claim, the related prophecy will be created. If claim message is not the first claim, then it will be added to the existed prophecy. If the power of validators which claim the same content reaches a threshold like 70%, the prophecy will be marked success and the hooks will execute the winning claim and the sequence of claim type will be increased. If there is no chance that the validators will reach a consensus, the prophecy will be marked failed and the prophecy will be deleted and the validators should start over again.","title":"Oracle Process\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#bridge-module","text":"Bridge module will process cross chain transactions. It contains two parts: transactions from BC to BSC and transactions from BSC to BC. For transactions from BSC to BC, it will depend on the oracle module. When the validators reach a consensus on a certain claim, the bridge module will process the transaction according to the claim, like transfer from BSC to BC. For transactions from BC to BSC, it will process the BC part of the transaction and write the related cross chain package for BSC.","title":"Bridge Module\u200b"},{"location":"Binance%20Cross-Chain%20Mechanism/#oracle-relayer","text":"The relayer is a service which monitors events on BSC, builds and broadcasts transactions to BC. Each validator operator should maintain its own relayer service. The relayer service requires to have access to the validator operator private key. All relayer service independently witness the peggy contract events, then build transactions to claim events to BC oracle module. The relay process: Continually listen for cross chain event Parse the cross-chain transfer parameters from event data Use this information to build an unsigned BC oracle transaction Sign and broadcast transaction. GitHub Implementation link: https://github.com/bnb-chain/oracle-relayer","title":"Oracle Relayer"},{"location":"Develop/","text":"BSC Mainnet What is Mainnet?\u200b Mainnet is the term used to describe when a blockchain protocol is fully developed and deployed, meaning that cryptocurrency transactions are being broadcasted, verified, and recorded on a distributed ledger technology (blockchain). BNB Smart Chain's mainnet can be used for deploying actual dApps on the BSC blockchain ad perform real transactions. Since this is the actual network, you will require to purchase real BNB tokens to perform different operations on the network. How to Get BNB\u200b There are multiple ways to purchase BNB Tokens for use on the mainnet. Other than the official BNB Extension Wallet , BNB Smart Chain supports several popular wallets like MetaMask and TrustWallet , to learn more about the supported wallets refer here. For a list of tutorials on how to use different supported wallets with BNB Smart Chain, refer here . How to Access BSC\u200b There are multiple ways to access the BSC mainnet. One possible method is to join the mainnet as a full node . You can also use the RPC endpoints specified here to connect to the mainnet. RPC endpoints may be used to interact with a node directly over HTTP or websockets. Using RPC, you may perform low-level operations like executing ABCI queries, viewing network/consensus state or broadcasting a transaction. RPC endpoints are also used with web wallets like MetaMask to connect to the BSC mainnet. How to Know BSC Ecosystem\u200b To get an overview of the BNB Smart Chain, refer here . To learn more about the ecosystem and the different development tools like APIs, IDEs, wallets, etc., that are available on the BSC network, you can refer here . You can visit BNBProject or DappRadar to view real-time ranking and tracking of BSC projects. How to Build on BSC\u200b You can build deploy smart contracts , NFTs , BEP20 Tokens , and BEP20 Upgradable Contracts on the BNB Smart Chain. BSC today\u200b To get an overview of what is the current state and the future developements that BSC's team is working refer here . BSC Testnet What is a Testnet?\u200b The testnet is a test environment for BNB Smart Chain network, run by the BNB Chain development community, which is open to developers. The validators on the testnet are from the development team. You can connect a node to the testnet by downloading the node binary to use this configuration . There is also a web wallet that can directly interact with the DEX testnet. What is the Testnet good for?\u200b Create your test address and get your testnet funds. Develop applications and try tutorials on BNB Smart Chain without the potential to lose your own assets. Test your applications against new versions of BNB Smart Chain. Analyze blockchain data on a smaller, non-trivial data set compared to the public network. How to get Testnet Fund?\u200b The testnet faucet for BNB Chain can be accessed here . Steps to claim testnet BNB: Create a new Wallet of BNB Smart Chain testnet with MetaMask or MathWallet Get Testnet Fund: https://testnet.binance.org/faucet-smart To request funds, please make a tweet with your BNB Smart Chain address pasted into the contents. Then, copy-paste the tweets URL! BNB will be sent to your BSC wallet right away. Transfer From BNB Smart Chain to Beacon Chain You can use BNB Chain Extension Wallet for cross-chain transfer. If you wish to test Beacon Chain features, you could transfer BNB cross-chain with MathWallet dApp: https://docs.bnbchain.org/docs/wallet/math#transfer-bnb-from-bsc-to-bc-in-testnet Explorers for Testnet\u200b * BscSCAN - https://testnet.bscscan.com/ * Bitquery - https://explorer.bitquery.io/bsc_testnet BSC Explorers BNB Smart Chain (BSC) explorers is a graphic user interface designed to allow users to interact with the blockchain. Through this interface, a user can browse information about blocks that have been added to the blockchain, transactions that have occurred on the blockchain, wallet balances, and information about BNB. BNB Smart Chain (BSC) provides explorers for both its mainnet and testnet. Explorers for Mainnet\u200b BscSCAN - https://bscscan.com/ Bitquery - https://explorer.bitquery.io/bsc Explorers for Testnet \u200b - BscSCAN - https://testnet.bscscan.com/ - Bitquery - https://explorer.bitquery.io/bsc_testnet Running Fullnode BNB Smart Chain Full Node How to Run A Fullnode on BNB Smart Chain Fullnodes Functions\u200b Stores the full blockchain history on disk and can answer the data request from the network. Receives and validates the new blocks and transactions. Verifies the states of every accounts. Supported Platforms\u200b We support running a full node on Mac OS X and Linux .* Suggested Requirements \u200b Fullnode \u200b - VPS running recent versions of Mac OS X or Linux. - IMPORTANT 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms. (if start with snap/fast sync, it will need NVMe SSD) - 16 cores of CPU and 64 gigabytes of memory (RAM). - Suggest m5zn.3xlarge instance type on AWS, c2-standard-16 on Google cloud. - A broadband Internet connection with upload/download speeds of 5 megabyte per second Validator\u200b VPS running recent versions of Mac OS X or Linux. IMPORTANT 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms 16 cores of CPU and 64 gigabytes of memory (RAM) Suggest m5zn.3xlarge instance type on AWS, or c2-standard-16 on Google cloud. A broadband Internet connection with upload/download speeds of 10 megabyte per second Settings \u200b Common Problems With Connectivity\u200b Sometimes you just can\u2019t get synced. The most common reasons are as follows: You have started geth without the discovery protocol, you can set the --nodiscover parameter to False. You only want this if you are running full node with fixed nodes. Update BootstrapNodes BootstrapNodes = [\"enode://1cc4534b14cfe351ab740a1418ab944a234ca2f702915eadb7e558a02010cb7c5a8c295a3b56bcefa7701c07752acd5539cb13df2aab8ae2d98934d712611443@52.71.43.172:30311\",\"enode://28b1d16562dac280dacaaf45d54516b85bc6c994252a9825c5cc4e080d3e53446d05f63ba495ea7d44d6c316b54cd92b245c5c328c37da24605c4a93a0d099c4@34.246.65.14:30311\",\"enode://5a7b996048d1b0a07683a949662c87c09b55247ce774aeee10bb886892e586e3c604564393292e38ef43c023ee9981e1f8b335766ec4f0f256e57f8640b079d5@35.73.137.11:30311\"] Add Static nodes Geth also supports a feature called static nodes if you have certain peers you always want to connect to. Static nodes are re-connected on disconnects. You can configure permanent static nodes by putting something like the following into <datadir>/geth/static-nodes.json: [ \"enode://pubkey@ip:port\", \"enode:// cfc556867894dc84707c2ce6290740d6ba112b279217e6db420f215397492a91ef76bbfe18ebd349a09b37fc8bfef5740d2d2335838e063094d5 b63c3fd20d8f@34.197.85.99:30311\", \"enode:// 7cf68af17a83f925f34eeced2a139b1d11bac03fd2635707e459a821965b5e6016021a43379f24dc428ebcb84b8fb377517dee6ae484cd276a2f 9360dac9c183@52.86.7.102:30311\", \"enode:// b2ed83944f4c0e18d6b2f5f6c2e86b0320c10b8a96f897a535b43f25dc625ae739f449765ad86f38a393472638fcef69f30d7af53b02c3545722 b1dd6f18f606@34.194.252.9:30311\", \"enode:// 42deadff5ff5d97ea4245128952335969fafea6c4ddd05146b3cac125099e1b2d1ea42c8d02c11ee8b5272a75d4f4b9f51a99244fd6daf1c6a1d 5017242a3d43@101.36.120.67:30311\", \"enode:// 905f585c09b8eed66afdf8a99acdab7487185357f33d5c9fe40332e4aa4a661382b159ffb300b20fbc12e81505505944ac3bfc7e6673b352d01e 09f2df8af5bc@152.32.131.34:30311\", \"enode:// e585bafb7ab5a187534d69e84531165e5d4b0ee4f76b21641fe778c53770cd72e1850d44b48ad00c08ca4dc860cd5c5afa04b23a5061303f61d2 658b1c48b9b2@152.32.132.171:30311\", \"enode:// 8fb5dd1259e0672efb8c141434bf0c24c73b338f7c2da15efc2def7403b952d453814230eeb97f555aaed46ee0b0b6e2a8568b518f88bd328729 031746114dd2@3.0.236.154:30311\", \"enode:// 8fb5dd1259e0672efb8c141434bf0c24c73b338f7c2da15efc2def7403b952d453814230eeb97f555aaed46ee0b0b6e2a8568b518f88bd328729 031746114dd2@3.0.236.154:30311\" ] You can also add static nodes at runtime via the js console using admin.addPeer(): admin.addPeer( \"enode://8fb5dd1259e0672efb8c141434bf0c24c73b338f7c2da15efc2def7403b952d453814230eeb97f555aaed46ee0b0b6e2a8568b518f88bd328729031746114dd2@3.0.236.154:30311\" ) Add Trusted nodes Geth supports trusted nodes that are always allowed to reconnect, even if the peer limit is reached. They can be added permanently via a config file <datadir>/geth/trusted-nodes.json or temporary via RPC call. Chaindata Snapshot\u200b Please download the chain data snapshot and extract to your home folder to speed up ## Extract the data unzip geth.zip -d /NAME_OF_YOUR_HOME/node & Sync Mode\u200b Fast Sync The default sync mode. Synchronizes a full node doing a fast synchronization by downloading the entire state database, requesting the headers first, and filling in block bodies and receipts afterward. Once the fast sync reaches the best block of the BNB Smart Chain network, it switches to full sync mode. Full Sync Synchronizes a full node starting at genesis, verifying all blocks and executing all transactions. This mode is a bit slower than the fast sync mode but comes with increased security. Steps to Run a Fullnode\u200b Sync From Snapshot (Recommended) \u200b 1. Download the pre-build binaries from release page or follow the instructions below: # Linux wget $(curl -s https://api.github.com/repos/bnb-chain/bsc/releases/latest |grep browser_ |grep geth_linux |cut -d\\\" -f4) # MacOS wget $(curl -s https://api.github.com/repos/bnb-chain/bsc/releases/latest |grep browser_ |grep geth_mac |cut -d\\\" -f4) Download the config files Download genesis.json and config.toml by: wget $(curl -s https://api.github.com/repos/bnb-chain/bsc/releases/latest |grep browser_ |grep mainnet |cut -d\\\" -f4) unzip mainnet.zip Download snapshot Download latest snapshot from Download site Follow the guide to structure the files. Start a full node geth --config ./config.toml --datadir ./node --diffsync --cache 8000 --rpc.allow-unprotected-txs --txlookuplimit 0 Sync From Genesis Block (Not Recommended)\u200b Build from source code Make sure that you have installed Go 1.13+ and have added GOPATH to PATH environment variable git clone https://github.com/bnb-chain/bsc # Enter the folder bsc was cloned into cd bsc # Compile and install bsc make geth or you can download the pre-build binaries from release page or follow the instructions below: # Linux wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep geth_linux |cut -d\\\" -f4) # MacOS wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep geth_mac |cut -d\\\" -f4) Download the config files Download genesis.json and config.toml by: ## mainet wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep mainnet |cut -d\\\" -f4) unzip mainnet.zip ## testnet wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep testnet |cut -d\\\" -f4) unzip testnet.zip Write genesis state locally geth --datadir node init genesis.json You could see the following output: INFO [05-19|14:53:17.468] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/chaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.498] Writing custom genesis block INFO [05-19|14:53:17.501] Persisted trie from memory database nodes=21 size=56.84KiB time=357.915\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.502] Successfully wrote genesis state database=chaindata hash=7d79cc\u2026fb0d1e INFO [05-19|14:53:17.503] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/lightchaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.524] Writing custom genesis block INFO [05-19|14:53:17.525] Persisted trie from memory database nodes=21 size=56.84KiB time=638.396\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.528] Successfully wrote genesis state database=lightchaindata hash=7d79cc\u2026fb0d1e Start your fullnode !!! Note BREAKING CHANGE: Non-EIP155 transactions (i.e. transactions which are not replay-protected) are now rejected by the RPC API. You can disable this restriction using the --rpc.allow-unprotected-txs command-line flag. ## start a full node geth --config ./config.toml --datadir ./node --cache 8000 --rpc.allow-unprotected-txs --txlookuplimit 0 Start a validator node ## generate the consensus key and input the password geth account new --datadir ./node echo {your-password} > password.txt geth --config ./config.toml --datadir ./node --syncmode snap -unlock {your-validator-address} --password password.txt --mine --allow-insecure-unlock --cache 8000 !!! Note Because the default value of TrieTimeout in config.toml is large, it means geth will not persist state into database until reach this time threshold, if the node has been force shutdown, it will start syncing from last state which may take long time. The recommended setting for valiidators is TrieTimeout = 100000000000 Monitor node status you can monitor the log from /node/bsc.log by default. Node Maintainence Peer Discovery\u200b The bootstrap nodes will be enhanced in the short future. So far, a discovery http service will provide some stable public p2p peers for syncing. Please visit https://api.binance.org/v1/discovery/peers to get dynamic peer info. You can append the peer info to the StaticNodes in the config.toml to enhance the networking of the full nodes. To avoid crowded networking, the discovery service will change the peer info from time to time, try fetch new ones if the connected peers of full node are too few. Binary\u200b All the clients are suggested to upgrade to the latest release . The latest version is supposed to be more stable and get better performance. Storage\u200b According to the test, the performance of a fullnode will degrade when the storage size exceeds 1.5T. We suggest the fullnode always keep light storage by pruning the storage. How to prune: Stop the BSC node. Run nohup geth snapshot prune-state --datadir {the data dir of your bsc node} & . It will take 3-5 hours to finish. Start the node once it is done. The maintainers should always have a few backup nodes. The hardware is also important, make sure the SSD meets: 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms. Diff Sync \u200b The diffsync protocol rolled out as a stable feature in release v1.1.5. Diff sync improves the syncing speed by 60%\uff5e70% approximately according to the test. All full nodes are suggested to enable it by adding --diffsync in the starting command. Light Storage\u200b When the node crashes or been force killed, the node will sync from a block that was a few minutes or a few hours ago. This is because the state in memory is not persisted into the database in real time, and the node needs to replay blocks from the last checkpoint once it start. The replaying time dependents on the configuration TrieTimeout in the config.toml. We suggest you raise it if you can tolerate with long replaying time, so the node can keep light storage. Upgrade Geth\u200b Please read this guide Download Blockchain Snapshot Chaindata Snapshot For latest chaindata snapshots visit here For v1.1.0:\u200b Latest Snapshot 2021-05-15 snapshot (size 220GB) checksum: 39e311c37a9844b4dd7fb218553cc99f 2021-05-13 snapshot (Size: 203G) 2021-05-02 snapshot (Size: 175G) For v1.0.7:\u200b 2021-04-15 snapshot (271 GB, md5sum 3ace16d3e2a52100025da387c73861a3f00de833) 2021-04-17 snapshot (260 GB, md5sum dd68c7fddaba42997eda013535a572cb) March snapshot: download (146 GB, md5sum 74ada3bcd6a9d0f101501919f6cc8a534e9d796e) February snapshot: download (87.4 GB, md5sum 6611dedde095ba9b72b50ebf6c35a8d7) The following commands are step by step instructions for BSC node operators that can be used for two major use-cases: Fixing nodes that are stuck or crashed; Jumpstarting a newly setup validator node; avoid waiting some hours for synchronization Basically, a compressed version of the last-known \"good\" chaindata is downloaded. Remove the node's old data and update it with the newly downloaded data. Finally, restart the sync-process from this known-good checkpoint. Note: Ensure there is enough disk space for both the zip file AND its uncompressed contents. Double the space or more. Download March Snapshot from CLI using wget wget --no-check-certificate --no-proxy 'https://s3.ap-northeast-1.amazonaws.com/dex-bin.bnbstatic.com/s3-witness-data-download/chaindata_202103.zip?AWSAccessKeyId=AKIAYINE6SBQPUZDDRRO&Expires=1641450253&Signature=hOC8I8HSpCOytlYMVQwKRc5oUaI%3D' Tip: extract the data in the background In case you can not wait for the extraction to finish, you can run it in the background # Extract the data nohup unzip /NAME_OF_YOUR_HOME/node/geth/ -f chaindata_202102.zip & # Start your node back geth --config ./config.toml --datadir ./node --syncmode snap Local BNB Smart Chain Network See also : https://github.com/ethereum/go-ethereum/wiki/Private-network Setting up your BSC Node(s) \u200b Pre-Requisites\u200b Install Geth\u200b Review the guide here Create /projects\u200b Create a /projects symbolic link (Note: This step is simply so \"/projects\" can be used in all other commands, instead you could use full paths, or set an env var) $ mkdir <my projects folder> $ sudo ln -s <my projects folder> /projects Create local_ethereum_blockchain folder $ mkdir /projects/local_ethereum_blockchain Create the genesis block config\u200b Create this file : /projects/local_ethereum_blockchain/genesis.json With the following contents : { \"config\": { \"chainId\": 1000, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0x0000000000000061\", \"timestamp\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x100\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x3333333333333333333333333333333333333333\", \"alloc\": {} } ( info about the genesis file ) Initialize an Ethereum node\u200b $ geth --datadir /projects/local_ethereum_blockchain/node1 init /projects/local_ethereum_blockchain/genesis.json Start the Ethereum node\u200b $ geth --datadir /projects/local_ethereum_blockchain/node1 --networkid 1000 console Initialize another Ethereum node\u200b $ geth --datadir /projects/local_ethereum_blockchain/node-2 init /projects/local_ethereum_blockchain/genesis.json Start the 2nd Ethereum node\u200b $ geth --datadir /projects/local_ethereum_blockchain/node-2 --port 30304 --nodiscover --networkid 1000 console Connect one node to the other\u200b In one geth console : > admin.nodeInfo.enode In the other console : > admin.addPeer( <the enode value from the first console> ) Useful geth commands\u200b Node info\u200b > admin.nodeInfo Peers\u200b Show peers > admin.peers How many peers ? > admin.peers.length Create an account\u200b You need an account to do be able to do things like mining > personal.newAccount() And make sure you remember/save the password! Unlock account\u200b Neccessary before some actions > personal.unlockAccount( eth.accounts[0] ) Start mining\u200b > miner.start(1) The first block may take a while to mine, allow a few minutes Stop mining\u200b > miner.stop() Current block number\u200b > eth.blockNumber Details of current block\u200b > eth.getBlock( eth.blockNumber ) Which node minded the last block\u200b > eth.getBlock(eth.blockNumber).miner Account balance, in ether\u200b > web3.fromWei(eth.getBalance(eth.accounts[0])) Transfer ether between accounts\u200b First get the account numbers by doing > eth.accounts Then unlock the account you are sending from > personal.unlockAccount( <from account> ) eg. > personal.unlockAccount(eth.accounts[0]) Finally transfer 1 ether > eth.sendTransaction({from: \"<from account>\", to: \"<to account>\", value: web3.toWei(1, \"ether\")}) Exit\u200b > exit (This will also stop the node from running if it was started using $ geth console (as opposed to $ geth attach )) Connect to other nodes on your network\u200b Get the IP of the node : $ ifconfig|grep netmask|awk '{print $2}' Get the enode of the node : > admin.nodeInfo.enode REPLACE [::] in the enode string with the [<ip address>] On your console > admin.addPeer(< the enode string with the ip address in it>) Upgrading Geth #### How to Upgrade Geth Updating geth is as easy as it gets. You just need to download and install the newer version of geth, shutdown your node and restart with the new software. Geth will automatically use the data of your old node and sync the latest blocks that were mined since you shut down the old software. Step 1: Compile the new version \u200b git clone https://github.com/bnb-chain/bsc # Enter the folder bsc was cloned into cd bsc # Comile and install bsc make geth Step 2: Stop Geth\u200b $ pid=`ps -ef | grep geth | grep -v grep | awk '{print $2}'` $ kill $pid Step 3: Restart\u200b ## start a full node geth --config ./config.toml --datadir ./node --syncmode snap RPC JSON-RPC Endpoint Available Resources\u200b Mainnet(ChainID 0x38, 56 in decimal)\u200b BSC RPC Endpoints: !!! NOTE You can make eth_getLogs requests with up to a 5K block range. If you need to pull logs frequently, we recommend using WebSockets to push new logs to you when they are available. Recommend https://bsc-dataseed.binance.org/ https://bsc-dataseed1.defibit.io/ https://bsc-dataseed1.ninicoin.io/ https://bsc.nodereal.io BC RPC Endpoints: https://dataseed1.binance.org/ https://dataseed2.binance.org/ https://dataseed3.binance.org/ https://dataseed4.binance.org/ https://dataseed1.defibit.io/ https://dataseed2.defibit.io/ https://dataseed3.defibit.io/ https://dataseed4.defibit.io/ https://dataseed1.ninicoin.io/ https://dataseed2.ninicoin.io/ https://dataseed3.ninicoin.io/ https://dataseed4.ninicoin.io/ Testnet(ChainID 0x61, 97 in decimal) \u200b BSC RPC Endpoints: https://data-seed-prebsc-1-s1.binance.org:8545/ https://data-seed-prebsc-2-s1.binance.org:8545/ https://data-seed-prebsc-1-s2.binance.org:8545/ https://data-seed-prebsc-2-s2.binance.org:8545/ https://data-seed-prebsc-1-s3.binance.org:8545/ https://data-seed-prebsc-2-s3.binance.org:8545/ BC RPC Endpoints: http://data-seed-pre-0-s1.binance.org:80 http://data-seed-pre-1-s1.binance.org:80 http://data-seed-pre-2-s1.binance.org:80 http://data-seed-pre-0-s3.binance.org:80 http://data-seed-pre-1-s3.binance.org:80 Rate limit\u200b The rate limit of BSC endpoint on Testnet and Mainnet is 8K/5min. 3rd Party Provider\u200b ANKR : https://app.ankr.com/api Chainstack : https://chainstack.com/build-better-with-binance-smart-chain/ GetBlock.io : https://getblock.io/nodes/bsc QuickNode : https://quicknode.com NodeReal : https://docs.nodereal.io/nodereal/meganode/introduction BlockVision : https://docs.blockvision.org/blockvision/chain-apis/bnb-chain-api Start\u200b You can start the HTTP JSON-RPC with the --rpc flag ## mainnet geth attach https://bsc-dataseed1.binance.org ## testnet geth attach https://data-seed-prebsc-1-s1.binance.org:8545/ JSON-RPC methods\u200b Please refer to this wiki page or use Postman: https://documenter.getpostman.com/view/4117254/ethereum-json-rpc/RVu7CT5J?version=latest Deploy Smart Contract Using Remix IDE Deploys a BEP20 smart contract with a message, and renders it in the front-end. You can interact with the smart contract easily! This dapp implements a \"Hello World\" style application that echoes a message passed to the contract to the front end. This tutorial is intended to be followed using the online IDE available at Remix IDE . Setting up Remix IDE\u200b Remix is an online IDE to develop smart contracts. You need to choose Solidity Compiler and Deploy and Run Transactions. Go to File Explorers, And Create a new file, Name it MegaCoin.sol Copy/Paste the Smart contract below into the newly created file MegaCoin.sol The smart contract\u200b Create new contract BEP20Token.sol and copy contract code from the bep20 token template here Modify \u201cname\u201d, \u201csymbol\u201d, \u201cdecimals\u201d and \u201ctotalSupply\u201d according to your requirements. The first line, pragma solidity ^0.5.16 specifies that the source code is for a Solidity version greater than 0.5.16. Pragmas are common instructions for compilers about how to treat the source code (e.g., pragma once). A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. Learn more about the constructor and memory in the docs. Compile Smart Contract\u200b Step1: Click button to switch to compile page Step2: Select \u201cBEP20Token\u201d contract Step3: Enable \u201cAuto compile\u201d and \u201coptimization\u201d Step4: Click \u201cABI\u201d to copy the contract abi and save it. Now, We have to deploy our smart contract on BNB Smart Chain Network. For that, we have to connect to web3 world, this can be done my many services like Metamask, Brave, Portis etc. We will be using Metamask. Please follow this tutorial to setup a Metamask Account . Open Metamask and select Custom RPC from the networks dropdown Go to setting page Add a new network Testnet RPC URLs ChainID: 97 Symbol: BNB Block Explorer: https://testnet.bscscan.com Mainnet RPC URLs ChainID: 56 Symbol: BNB Block Explorer: https://bscscan.com Go ahead and click save Copy your address from Metamask Head over to Faucet and request test BNB Now, let's Deploy the Smart Contract on BNB Smart Chain Testnet Select Injected Web3 in the Environment dropdown and your contract Accept the Connection Request! Once Metamask is connected to Remix, the \u2018Deploy\u2019 transaction would generate another metamask popup that requires transaction confirmation. Congratulations! You have successfully deployed a BEP20 Contract. Now you can interact with the Smart Contract. Check the deployment status here: https://testnet.bscscan.com/","title":"Develop"},{"location":"Develop/#_1","text":"","title":""},{"location":"Develop/#bsc-mainnet","text":"","title":"BSC Mainnet"},{"location":"Develop/#what-is-mainnet","text":"Mainnet is the term used to describe when a blockchain protocol is fully developed and deployed, meaning that cryptocurrency transactions are being broadcasted, verified, and recorded on a distributed ledger technology (blockchain). BNB Smart Chain's mainnet can be used for deploying actual dApps on the BSC blockchain ad perform real transactions. Since this is the actual network, you will require to purchase real BNB tokens to perform different operations on the network.","title":"What is Mainnet?\u200b"},{"location":"Develop/#how-to-get-bnb","text":"There are multiple ways to purchase BNB Tokens for use on the mainnet. Other than the official BNB Extension Wallet , BNB Smart Chain supports several popular wallets like MetaMask and TrustWallet , to learn more about the supported wallets refer here. For a list of tutorials on how to use different supported wallets with BNB Smart Chain, refer here .","title":"How to Get BNB\u200b"},{"location":"Develop/#how-to-access-bsc","text":"There are multiple ways to access the BSC mainnet. One possible method is to join the mainnet as a full node . You can also use the RPC endpoints specified here to connect to the mainnet. RPC endpoints may be used to interact with a node directly over HTTP or websockets. Using RPC, you may perform low-level operations like executing ABCI queries, viewing network/consensus state or broadcasting a transaction. RPC endpoints are also used with web wallets like MetaMask to connect to the BSC mainnet.","title":"How to Access BSC\u200b"},{"location":"Develop/#how-to-know-bsc-ecosystem","text":"To get an overview of the BNB Smart Chain, refer here . To learn more about the ecosystem and the different development tools like APIs, IDEs, wallets, etc., that are available on the BSC network, you can refer here . You can visit BNBProject or DappRadar to view real-time ranking and tracking of BSC projects.","title":"How to Know BSC Ecosystem\u200b"},{"location":"Develop/#how-to-build-on-bsc","text":"You can build deploy smart contracts , NFTs , BEP20 Tokens , and BEP20 Upgradable Contracts on the BNB Smart Chain.","title":"How to Build on BSC\u200b"},{"location":"Develop/#bsc-today","text":"To get an overview of what is the current state and the future developements that BSC's team is working refer here .","title":"BSC today\u200b"},{"location":"Develop/#bsc-testnet","text":"","title":"BSC Testnet"},{"location":"Develop/#what-is-a-testnet","text":"The testnet is a test environment for BNB Smart Chain network, run by the BNB Chain development community, which is open to developers. The validators on the testnet are from the development team. You can connect a node to the testnet by downloading the node binary to use this configuration . There is also a web wallet that can directly interact with the DEX testnet.","title":"What is a Testnet?\u200b"},{"location":"Develop/#what-is-the-testnet-good-for","text":"Create your test address and get your testnet funds. Develop applications and try tutorials on BNB Smart Chain without the potential to lose your own assets. Test your applications against new versions of BNB Smart Chain. Analyze blockchain data on a smaller, non-trivial data set compared to the public network.","title":"What is the Testnet good for?\u200b"},{"location":"Develop/#how-to-get-testnet-fund","text":"The testnet faucet for BNB Chain can be accessed here . Steps to claim testnet BNB: Create a new Wallet of BNB Smart Chain testnet with MetaMask or MathWallet Get Testnet Fund: https://testnet.binance.org/faucet-smart To request funds, please make a tweet with your BNB Smart Chain address pasted into the contents. Then, copy-paste the tweets URL! BNB will be sent to your BSC wallet right away. Transfer From BNB Smart Chain to Beacon Chain You can use BNB Chain Extension Wallet for cross-chain transfer. If you wish to test Beacon Chain features, you could transfer BNB cross-chain with MathWallet dApp: https://docs.bnbchain.org/docs/wallet/math#transfer-bnb-from-bsc-to-bc-in-testnet","title":"How to get Testnet Fund?\u200b"},{"location":"Develop/#explorers-for-testnet","text":"* BscSCAN - https://testnet.bscscan.com/ * Bitquery - https://explorer.bitquery.io/bsc_testnet","title":"Explorers for Testnet\u200b"},{"location":"Develop/#bsc-explorers","text":"BNB Smart Chain (BSC) explorers is a graphic user interface designed to allow users to interact with the blockchain. Through this interface, a user can browse information about blocks that have been added to the blockchain, transactions that have occurred on the blockchain, wallet balances, and information about BNB. BNB Smart Chain (BSC) provides explorers for both its mainnet and testnet.","title":"BSC Explorers"},{"location":"Develop/#explorers-for-mainnet","text":"BscSCAN - https://bscscan.com/ Bitquery - https://explorer.bitquery.io/bsc","title":"Explorers for Mainnet\u200b"},{"location":"Develop/#explorers-for-testnet_1","text":"\u200b - BscSCAN - https://testnet.bscscan.com/ - Bitquery - https://explorer.bitquery.io/bsc_testnet","title":"Explorers for Testnet"},{"location":"Develop/#running-fullnode","text":"","title":"Running Fullnode"},{"location":"Develop/#bnb-smart-chain-full-node","text":"","title":"BNB Smart Chain Full Node"},{"location":"Develop/#how-to-run-a-fullnode-on-bnb-smart-chain","text":"","title":"How to Run A Fullnode on BNB Smart Chain"},{"location":"Develop/#fullnodes-functions","text":"Stores the full blockchain history on disk and can answer the data request from the network. Receives and validates the new blocks and transactions. Verifies the states of every accounts.","title":"Fullnodes Functions\u200b"},{"location":"Develop/#supported-platforms","text":"We support running a full node on Mac OS X and Linux .*","title":"Supported Platforms\u200b"},{"location":"Develop/#suggested-requirements","text":"\u200b Fullnode \u200b - VPS running recent versions of Mac OS X or Linux. - IMPORTANT 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms. (if start with snap/fast sync, it will need NVMe SSD) - 16 cores of CPU and 64 gigabytes of memory (RAM). - Suggest m5zn.3xlarge instance type on AWS, c2-standard-16 on Google cloud. - A broadband Internet connection with upload/download speeds of 5 megabyte per second Validator\u200b VPS running recent versions of Mac OS X or Linux. IMPORTANT 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms 16 cores of CPU and 64 gigabytes of memory (RAM) Suggest m5zn.3xlarge instance type on AWS, or c2-standard-16 on Google cloud. A broadband Internet connection with upload/download speeds of 10 megabyte per second","title":"Suggested Requirements"},{"location":"Develop/#settings","text":"\u200b Common Problems With Connectivity\u200b Sometimes you just can\u2019t get synced. The most common reasons are as follows: You have started geth without the discovery protocol, you can set the --nodiscover parameter to False. You only want this if you are running full node with fixed nodes. Update BootstrapNodes BootstrapNodes = [\"enode://1cc4534b14cfe351ab740a1418ab944a234ca2f702915eadb7e558a02010cb7c5a8c295a3b56bcefa7701c07752acd5539cb13df2aab8ae2d98934d712611443@52.71.43.172:30311\",\"enode://28b1d16562dac280dacaaf45d54516b85bc6c994252a9825c5cc4e080d3e53446d05f63ba495ea7d44d6c316b54cd92b245c5c328c37da24605c4a93a0d099c4@34.246.65.14:30311\",\"enode://5a7b996048d1b0a07683a949662c87c09b55247ce774aeee10bb886892e586e3c604564393292e38ef43c023ee9981e1f8b335766ec4f0f256e57f8640b079d5@35.73.137.11:30311\"] Add Static nodes Geth also supports a feature called static nodes if you have certain peers you always want to connect to. Static nodes are re-connected on disconnects. You can configure permanent static nodes by putting something like the following into <datadir>/geth/static-nodes.json: [ \"enode://pubkey@ip:port\", \"enode:// cfc556867894dc84707c2ce6290740d6ba112b279217e6db420f215397492a91ef76bbfe18ebd349a09b37fc8bfef5740d2d2335838e063094d5 b63c3fd20d8f@34.197.85.99:30311\", \"enode:// 7cf68af17a83f925f34eeced2a139b1d11bac03fd2635707e459a821965b5e6016021a43379f24dc428ebcb84b8fb377517dee6ae484cd276a2f 9360dac9c183@52.86.7.102:30311\", \"enode:// b2ed83944f4c0e18d6b2f5f6c2e86b0320c10b8a96f897a535b43f25dc625ae739f449765ad86f38a393472638fcef69f30d7af53b02c3545722 b1dd6f18f606@34.194.252.9:30311\", \"enode:// 42deadff5ff5d97ea4245128952335969fafea6c4ddd05146b3cac125099e1b2d1ea42c8d02c11ee8b5272a75d4f4b9f51a99244fd6daf1c6a1d 5017242a3d43@101.36.120.67:30311\", \"enode:// 905f585c09b8eed66afdf8a99acdab7487185357f33d5c9fe40332e4aa4a661382b159ffb300b20fbc12e81505505944ac3bfc7e6673b352d01e 09f2df8af5bc@152.32.131.34:30311\", \"enode:// e585bafb7ab5a187534d69e84531165e5d4b0ee4f76b21641fe778c53770cd72e1850d44b48ad00c08ca4dc860cd5c5afa04b23a5061303f61d2 658b1c48b9b2@152.32.132.171:30311\", \"enode:// 8fb5dd1259e0672efb8c141434bf0c24c73b338f7c2da15efc2def7403b952d453814230eeb97f555aaed46ee0b0b6e2a8568b518f88bd328729 031746114dd2@3.0.236.154:30311\", \"enode:// 8fb5dd1259e0672efb8c141434bf0c24c73b338f7c2da15efc2def7403b952d453814230eeb97f555aaed46ee0b0b6e2a8568b518f88bd328729 031746114dd2@3.0.236.154:30311\" ] You can also add static nodes at runtime via the js console using admin.addPeer(): admin.addPeer( \"enode://8fb5dd1259e0672efb8c141434bf0c24c73b338f7c2da15efc2def7403b952d453814230eeb97f555aaed46ee0b0b6e2a8568b518f88bd328729031746114dd2@3.0.236.154:30311\" ) Add Trusted nodes Geth supports trusted nodes that are always allowed to reconnect, even if the peer limit is reached. They can be added permanently via a config file <datadir>/geth/trusted-nodes.json or temporary via RPC call.","title":"Settings"},{"location":"Develop/#chaindata-snapshot","text":"Please download the chain data snapshot and extract to your home folder to speed up ## Extract the data unzip geth.zip -d /NAME_OF_YOUR_HOME/node & Sync Mode\u200b Fast Sync The default sync mode. Synchronizes a full node doing a fast synchronization by downloading the entire state database, requesting the headers first, and filling in block bodies and receipts afterward. Once the fast sync reaches the best block of the BNB Smart Chain network, it switches to full sync mode. Full Sync Synchronizes a full node starting at genesis, verifying all blocks and executing all transactions. This mode is a bit slower than the fast sync mode but comes with increased security.","title":"Chaindata Snapshot\u200b"},{"location":"Develop/#steps-to-run-a-fullnode","text":"Sync From Snapshot (Recommended) \u200b 1. Download the pre-build binaries from release page or follow the instructions below: # Linux wget $(curl -s https://api.github.com/repos/bnb-chain/bsc/releases/latest |grep browser_ |grep geth_linux |cut -d\\\" -f4) # MacOS wget $(curl -s https://api.github.com/repos/bnb-chain/bsc/releases/latest |grep browser_ |grep geth_mac |cut -d\\\" -f4) Download the config files Download genesis.json and config.toml by: wget $(curl -s https://api.github.com/repos/bnb-chain/bsc/releases/latest |grep browser_ |grep mainnet |cut -d\\\" -f4) unzip mainnet.zip Download snapshot Download latest snapshot from Download site Follow the guide to structure the files. Start a full node geth --config ./config.toml --datadir ./node --diffsync --cache 8000 --rpc.allow-unprotected-txs --txlookuplimit 0 Sync From Genesis Block (Not Recommended)\u200b Build from source code Make sure that you have installed Go 1.13+ and have added GOPATH to PATH environment variable git clone https://github.com/bnb-chain/bsc # Enter the folder bsc was cloned into cd bsc # Compile and install bsc make geth or you can download the pre-build binaries from release page or follow the instructions below: # Linux wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep geth_linux |cut -d\\\" -f4) # MacOS wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep geth_mac |cut -d\\\" -f4) Download the config files Download genesis.json and config.toml by: ## mainet wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep mainnet |cut -d\\\" -f4) unzip mainnet.zip ## testnet wget $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep testnet |cut -d\\\" -f4) unzip testnet.zip Write genesis state locally geth --datadir node init genesis.json You could see the following output: INFO [05-19|14:53:17.468] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/chaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.498] Writing custom genesis block INFO [05-19|14:53:17.501] Persisted trie from memory database nodes=21 size=56.84KiB time=357.915\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.502] Successfully wrote genesis state database=chaindata hash=7d79cc\u2026fb0d1e INFO [05-19|14:53:17.503] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/lightchaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.524] Writing custom genesis block INFO [05-19|14:53:17.525] Persisted trie from memory database nodes=21 size=56.84KiB time=638.396\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.528] Successfully wrote genesis state database=lightchaindata hash=7d79cc\u2026fb0d1e Start your fullnode !!! Note BREAKING CHANGE: Non-EIP155 transactions (i.e. transactions which are not replay-protected) are now rejected by the RPC API. You can disable this restriction using the --rpc.allow-unprotected-txs command-line flag. ## start a full node geth --config ./config.toml --datadir ./node --cache 8000 --rpc.allow-unprotected-txs --txlookuplimit 0 Start a validator node ## generate the consensus key and input the password geth account new --datadir ./node echo {your-password} > password.txt geth --config ./config.toml --datadir ./node --syncmode snap -unlock {your-validator-address} --password password.txt --mine --allow-insecure-unlock --cache 8000 !!! Note Because the default value of TrieTimeout in config.toml is large, it means geth will not persist state into database until reach this time threshold, if the node has been force shutdown, it will start syncing from last state which may take long time. The recommended setting for valiidators is TrieTimeout = 100000000000 Monitor node status you can monitor the log from /node/bsc.log by default.","title":"Steps to Run a Fullnode\u200b"},{"location":"Develop/#node-maintainence","text":"Peer Discovery\u200b The bootstrap nodes will be enhanced in the short future. So far, a discovery http service will provide some stable public p2p peers for syncing. Please visit https://api.binance.org/v1/discovery/peers to get dynamic peer info. You can append the peer info to the StaticNodes in the config.toml to enhance the networking of the full nodes. To avoid crowded networking, the discovery service will change the peer info from time to time, try fetch new ones if the connected peers of full node are too few. Binary\u200b All the clients are suggested to upgrade to the latest release . The latest version is supposed to be more stable and get better performance. Storage\u200b According to the test, the performance of a fullnode will degrade when the storage size exceeds 1.5T. We suggest the fullnode always keep light storage by pruning the storage. How to prune: Stop the BSC node. Run nohup geth snapshot prune-state --datadir {the data dir of your bsc node} & . It will take 3-5 hours to finish. Start the node once it is done. The maintainers should always have a few backup nodes. The hardware is also important, make sure the SSD meets: 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms. Diff Sync \u200b The diffsync protocol rolled out as a stable feature in release v1.1.5. Diff sync improves the syncing speed by 60%\uff5e70% approximately according to the test. All full nodes are suggested to enable it by adding --diffsync in the starting command. Light Storage\u200b When the node crashes or been force killed, the node will sync from a block that was a few minutes or a few hours ago. This is because the state in memory is not persisted into the database in real time, and the node needs to replay blocks from the last checkpoint once it start. The replaying time dependents on the configuration TrieTimeout in the config.toml. We suggest you raise it if you can tolerate with long replaying time, so the node can keep light storage.","title":"Node Maintainence"},{"location":"Develop/#upgrade-geth","text":"Please read this guide","title":"Upgrade Geth\u200b"},{"location":"Develop/#download-blockchain-snapshot","text":"","title":"Download Blockchain Snapshot"},{"location":"Develop/#chaindata-snapshot_1","text":"For latest chaindata snapshots visit here For v1.1.0:\u200b Latest Snapshot 2021-05-15 snapshot (size 220GB) checksum: 39e311c37a9844b4dd7fb218553cc99f 2021-05-13 snapshot (Size: 203G) 2021-05-02 snapshot (Size: 175G) For v1.0.7:\u200b 2021-04-15 snapshot (271 GB, md5sum 3ace16d3e2a52100025da387c73861a3f00de833) 2021-04-17 snapshot (260 GB, md5sum dd68c7fddaba42997eda013535a572cb) March snapshot: download (146 GB, md5sum 74ada3bcd6a9d0f101501919f6cc8a534e9d796e) February snapshot: download (87.4 GB, md5sum 6611dedde095ba9b72b50ebf6c35a8d7) The following commands are step by step instructions for BSC node operators that can be used for two major use-cases: Fixing nodes that are stuck or crashed; Jumpstarting a newly setup validator node; avoid waiting some hours for synchronization Basically, a compressed version of the last-known \"good\" chaindata is downloaded. Remove the node's old data and update it with the newly downloaded data. Finally, restart the sync-process from this known-good checkpoint. Note: Ensure there is enough disk space for both the zip file AND its uncompressed contents. Double the space or more. Download March Snapshot from CLI using wget wget --no-check-certificate --no-proxy 'https://s3.ap-northeast-1.amazonaws.com/dex-bin.bnbstatic.com/s3-witness-data-download/chaindata_202103.zip?AWSAccessKeyId=AKIAYINE6SBQPUZDDRRO&Expires=1641450253&Signature=hOC8I8HSpCOytlYMVQwKRc5oUaI%3D' Tip: extract the data in the background In case you can not wait for the extraction to finish, you can run it in the background # Extract the data nohup unzip /NAME_OF_YOUR_HOME/node/geth/ -f chaindata_202102.zip & # Start your node back geth --config ./config.toml --datadir ./node --syncmode snap","title":"Chaindata Snapshot"},{"location":"Develop/#local-bnb-smart-chain-network","text":"See also : https://github.com/ethereum/go-ethereum/wiki/Private-network","title":"Local BNB Smart Chain Network"},{"location":"Develop/#setting-up-your-bsc-nodes","text":"\u200b","title":"Setting up your BSC Node(s)"},{"location":"Develop/#pre-requisites","text":"Install Geth\u200b Review the guide here Create /projects\u200b Create a /projects symbolic link (Note: This step is simply so \"/projects\" can be used in all other commands, instead you could use full paths, or set an env var) $ mkdir <my projects folder> $ sudo ln -s <my projects folder> /projects Create local_ethereum_blockchain folder $ mkdir /projects/local_ethereum_blockchain","title":"Pre-Requisites\u200b"},{"location":"Develop/#create-the-genesis-block-config","text":"Create this file : /projects/local_ethereum_blockchain/genesis.json With the following contents : { \"config\": { \"chainId\": 1000, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0x0000000000000061\", \"timestamp\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x100\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x3333333333333333333333333333333333333333\", \"alloc\": {} } ( info about the genesis file )","title":"Create the genesis block config\u200b"},{"location":"Develop/#initialize-an-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node1 init /projects/local_ethereum_blockchain/genesis.json","title":"Initialize an Ethereum node\u200b"},{"location":"Develop/#start-the-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node1 --networkid 1000 console","title":"Start the Ethereum node\u200b"},{"location":"Develop/#initialize-another-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node-2 init /projects/local_ethereum_blockchain/genesis.json","title":"Initialize another Ethereum node\u200b"},{"location":"Develop/#start-the-2nd-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node-2 --port 30304 --nodiscover --networkid 1000 console","title":"Start the 2nd Ethereum node\u200b"},{"location":"Develop/#connect-one-node-to-the-other","text":"In one geth console : > admin.nodeInfo.enode In the other console : > admin.addPeer( <the enode value from the first console> )","title":"Connect one node to the other\u200b"},{"location":"Develop/#useful-geth-commands","text":"","title":"Useful geth commands\u200b"},{"location":"Develop/#node-info","text":"> admin.nodeInfo","title":"Node info\u200b"},{"location":"Develop/#peers","text":"Show peers > admin.peers How many peers ? > admin.peers.length","title":"Peers\u200b"},{"location":"Develop/#create-an-account","text":"You need an account to do be able to do things like mining > personal.newAccount() And make sure you remember/save the password!","title":"Create an account\u200b"},{"location":"Develop/#unlock-account","text":"Neccessary before some actions > personal.unlockAccount( eth.accounts[0] )","title":"Unlock account\u200b"},{"location":"Develop/#start-mining","text":"> miner.start(1) The first block may take a while to mine, allow a few minutes","title":"Start mining\u200b"},{"location":"Develop/#stop-mining","text":"> miner.stop()","title":"Stop mining\u200b"},{"location":"Develop/#current-block-number","text":"> eth.blockNumber","title":"Current block number\u200b"},{"location":"Develop/#details-of-current-block","text":"> eth.getBlock( eth.blockNumber )","title":"Details of current block\u200b"},{"location":"Develop/#which-node-minded-the-last-block","text":"> eth.getBlock(eth.blockNumber).miner","title":"Which node minded the last block\u200b"},{"location":"Develop/#account-balance-in-ether","text":"> web3.fromWei(eth.getBalance(eth.accounts[0]))","title":"Account balance, in ether\u200b"},{"location":"Develop/#transfer-ether-between-accounts","text":"First get the account numbers by doing > eth.accounts Then unlock the account you are sending from > personal.unlockAccount( <from account> ) eg. > personal.unlockAccount(eth.accounts[0]) Finally transfer 1 ether > eth.sendTransaction({from: \"<from account>\", to: \"<to account>\", value: web3.toWei(1, \"ether\")})","title":"Transfer ether between accounts\u200b"},{"location":"Develop/#exit","text":"> exit (This will also stop the node from running if it was started using $ geth console (as opposed to $ geth attach ))","title":"Exit\u200b"},{"location":"Develop/#connect-to-other-nodes-on-your-network","text":"Get the IP of the node : $ ifconfig|grep netmask|awk '{print $2}' Get the enode of the node : > admin.nodeInfo.enode REPLACE [::] in the enode string with the [<ip address>] On your console > admin.addPeer(< the enode string with the ip address in it>)","title":"Connect to other nodes on your network\u200b"},{"location":"Develop/#upgrading-geth","text":"#### How to Upgrade Geth Updating geth is as easy as it gets. You just need to download and install the newer version of geth, shutdown your node and restart with the new software. Geth will automatically use the data of your old node and sync the latest blocks that were mined since you shut down the old software. Step 1: Compile the new version \u200b git clone https://github.com/bnb-chain/bsc # Enter the folder bsc was cloned into cd bsc # Comile and install bsc make geth Step 2: Stop Geth\u200b $ pid=`ps -ef | grep geth | grep -v grep | awk '{print $2}'` $ kill $pid Step 3: Restart\u200b ## start a full node geth --config ./config.toml --datadir ./node --syncmode snap","title":"Upgrading Geth"},{"location":"Develop/#rpc","text":"","title":"RPC"},{"location":"Develop/#json-rpc-endpoint","text":"","title":"JSON-RPC Endpoint"},{"location":"Develop/#available-resources","text":"Mainnet(ChainID 0x38, 56 in decimal)\u200b BSC RPC Endpoints: !!! NOTE You can make eth_getLogs requests with up to a 5K block range. If you need to pull logs frequently, we recommend using WebSockets to push new logs to you when they are available. Recommend https://bsc-dataseed.binance.org/ https://bsc-dataseed1.defibit.io/ https://bsc-dataseed1.ninicoin.io/ https://bsc.nodereal.io BC RPC Endpoints: https://dataseed1.binance.org/ https://dataseed2.binance.org/ https://dataseed3.binance.org/ https://dataseed4.binance.org/ https://dataseed1.defibit.io/ https://dataseed2.defibit.io/ https://dataseed3.defibit.io/ https://dataseed4.defibit.io/ https://dataseed1.ninicoin.io/ https://dataseed2.ninicoin.io/ https://dataseed3.ninicoin.io/ https://dataseed4.ninicoin.io/ Testnet(ChainID 0x61, 97 in decimal) \u200b BSC RPC Endpoints: https://data-seed-prebsc-1-s1.binance.org:8545/ https://data-seed-prebsc-2-s1.binance.org:8545/ https://data-seed-prebsc-1-s2.binance.org:8545/ https://data-seed-prebsc-2-s2.binance.org:8545/ https://data-seed-prebsc-1-s3.binance.org:8545/ https://data-seed-prebsc-2-s3.binance.org:8545/ BC RPC Endpoints: http://data-seed-pre-0-s1.binance.org:80 http://data-seed-pre-1-s1.binance.org:80 http://data-seed-pre-2-s1.binance.org:80 http://data-seed-pre-0-s3.binance.org:80 http://data-seed-pre-1-s3.binance.org:80 Rate limit\u200b The rate limit of BSC endpoint on Testnet and Mainnet is 8K/5min. 3rd Party Provider\u200b ANKR : https://app.ankr.com/api Chainstack : https://chainstack.com/build-better-with-binance-smart-chain/ GetBlock.io : https://getblock.io/nodes/bsc QuickNode : https://quicknode.com NodeReal : https://docs.nodereal.io/nodereal/meganode/introduction BlockVision : https://docs.blockvision.org/blockvision/chain-apis/bnb-chain-api Start\u200b You can start the HTTP JSON-RPC with the --rpc flag ## mainnet geth attach https://bsc-dataseed1.binance.org ## testnet geth attach https://data-seed-prebsc-1-s1.binance.org:8545/ JSON-RPC methods\u200b Please refer to this wiki page or use Postman: https://documenter.getpostman.com/view/4117254/ethereum-json-rpc/RVu7CT5J?version=latest","title":"Available Resources\u200b"},{"location":"Develop/#deploy-smart-contract","text":"","title":"Deploy Smart Contract"},{"location":"Develop/#using-remix-ide","text":"Deploys a BEP20 smart contract with a message, and renders it in the front-end. You can interact with the smart contract easily! This dapp implements a \"Hello World\" style application that echoes a message passed to the contract to the front end. This tutorial is intended to be followed using the online IDE available at Remix IDE . Setting up Remix IDE\u200b Remix is an online IDE to develop smart contracts. You need to choose Solidity Compiler and Deploy and Run Transactions. Go to File Explorers, And Create a new file, Name it MegaCoin.sol Copy/Paste the Smart contract below into the newly created file MegaCoin.sol The smart contract\u200b Create new contract BEP20Token.sol and copy contract code from the bep20 token template here Modify \u201cname\u201d, \u201csymbol\u201d, \u201cdecimals\u201d and \u201ctotalSupply\u201d according to your requirements. The first line, pragma solidity ^0.5.16 specifies that the source code is for a Solidity version greater than 0.5.16. Pragmas are common instructions for compilers about how to treat the source code (e.g., pragma once). A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. Learn more about the constructor and memory in the docs. Compile Smart Contract\u200b Step1: Click button to switch to compile page Step2: Select \u201cBEP20Token\u201d contract Step3: Enable \u201cAuto compile\u201d and \u201coptimization\u201d Step4: Click \u201cABI\u201d to copy the contract abi and save it. Now, We have to deploy our smart contract on BNB Smart Chain Network. For that, we have to connect to web3 world, this can be done my many services like Metamask, Brave, Portis etc. We will be using Metamask. Please follow this tutorial to setup a Metamask Account . Open Metamask and select Custom RPC from the networks dropdown Go to setting page Add a new network Testnet RPC URLs ChainID: 97 Symbol: BNB Block Explorer: https://testnet.bscscan.com Mainnet RPC URLs ChainID: 56 Symbol: BNB Block Explorer: https://bscscan.com Go ahead and click save Copy your address from Metamask Head over to Faucet and request test BNB Now, let's Deploy the Smart Contract on BNB Smart Chain Testnet Select Injected Web3 in the Environment dropdown and your contract Accept the Connection Request! Once Metamask is connected to Remix, the \u2018Deploy\u2019 transaction would generate another metamask popup that requires transaction confirmation. Congratulations! You have successfully deployed a BEP20 Contract. Now you can interact with the Smart Contract. Check the deployment status here: https://testnet.bscscan.com/","title":"Using Remix IDE"},{"location":"GettingStarted/","text":"Getting Started The purpose of this tutorial is to give a general overview of BNB Chain and to serve as a starting point for new users to the BNB Chain ecosystem. General knowledge of cryptocurrency is assumed, and in particular familiarity with the Ethereum ecosystem. If you don't understand something right away, that's OK. Search for an answer online, and if you don't find it, ask on our Discord . We recommend reading this document entirely before using BNB Chain so that you can avoid common pitfalls and problems that new users run into. There are many multiple components of the BNB Chain, so it's best to get a full picture of things before diving in to save yourself confusion. You can find a general overview of BNB Chain here . It will be useful in understanding similarities and differences between BNB Chain and other platforms. BNB Chain: Beacon Chain and BNB Smart Chain BNB Chain is composed of two blockchains - Beacon Chain (BC) and BNB Smart Chain (BSC). The Beacon Chain is the blockchain component that is responsible for the governance of the BNB Chain and manages staking and voting on the BNB Chain . Whereas, the BNB Smart Chain is the blokchain component that is EVM compatible, consensus layers, and with hubs to multi-chains. What can you do with Beacon Chain(BC)?\u200b The purpose of the Beacon Chain is to provide an efficient blockchain ecosystem that works along a DEX to provide an alternative marketplace for issuing and exchanging digital assets in a decentralized manner. You can: Send and receive BNB Issue new tokens to digitalize assets , and use Beacon Chain as underlying exchange/transfer network for the assets Send, receive, burn / mint and freeze / unfreeze tokens Sumbit an on-chain governance proposal for BNB Smart Chain For traders , you can: Propo*se to create trading pairs between two different tokens Send orders to buy or sell assets through trading pairs created on the chain withSDK Watch the DEX market to confirm price and market activity of certain assets For developers, you can also: Explore the transaction history and blocks on the chain, via Binance Chain Explore, API and node RPC interfaces. Run a full node to listen to and broadcast live updates on transactions, blocks, and consensus activities Extract other data of Binance Chain via full node or APIs Develop tools and applications to help users use Binance Chain and Binance DEX What can you do with BNB Smart Chain (BSC)?\u200b BNB Smart Chain (BSC) is best described as a blockchain that runs in parallel to the Beacon Chain. Unlike Beacon Chain, BSC boasts smart contract functionality and compatibility with the Ethereum Virtual Machine (EVM). The design goal here was to leave the high throughput of Beacon Chain intact while introducing smart contracts into its ecosystem. Because BSC is EVM-compatible, it launched with support for the rich universe of Ethereum tools and DApps. In theory, this makes it easy for developers to port their projects over from Ethereum. For users, it means that applications like MetaMask can be easily configured to work with BSC. Seriously \u2013 it\u2019s just a matter of tweaking a couple of settings. Check out Use MetaMask for BNB Smart Chain to get started. You can: Send and receive BNB and other BEP2 tokens cross-chain Explore the transaction history and blocks on the chain, via bscscan , API and node RPC interfaces. Stake your BNB to earn some block rewards Developers can also: Issue new tokens to digitalize assets Migrate existing DApps Run a full node to listen to and broadcast live updates on transactions, blocks, and consensus activities Become a validator of BSC - testnet and [mainnet]](/docs/validator/guideline-mainnet) Develop wallets and tools to help users use Dapps Wallet The easiest way to use BNB Beacon and BNB Smart Chain is through a wallet with support for accounts and transfers on these chains. BNB Chain provides a Web Wallet at https://www.bnbchain.world/en . BNB Chain also provides Web Wallet for testnet at https://testnet.binance.org . Both provide the functions described below: Generating crypto keys and addresses, which serves as the base of a wallet Showing the balances of assets on the addresses Sending and receiving assets Binance Web Wallet also presents a trading UI, where you can examine market data and manage your orders to trade among the listed assets. BNB Smart Chain supports several popular wallets like MetaMask and TrustWallet , to learn more about the supported wallets refer here . For a list of tutorials on how to use other supported wallets with BNB Smart Chain, refer here . BNB Token and Fees\u200b BNB is the cryptocurrency coin that powers the BNB Chain ecosystem. As one of the world's most popular utility tokens, not only can you trade BNB like any other cryptocurrency, you can also use BNB in a wide range of applications and use cases. Although initially based on the Ethereum network, the ERC-20 BNB tokens were later swapped with BEP-2 BNB at a 1:1 ratio. The BEP-2 BNB is the native coin of the Beacon Chain, and the mainnet. In 2020, the BNB Smart Chain (BSC) was launched. BSC is a blockchain network that runs in parallel with the BNB Beacon Chain. This means that BNB can be found in three different forms: BNB BEP-2 on the BNB Beacon Chain. BNB BEP-20 on the BNB Smart Chain. BNB ERC-20 on the Ethereum network. How to Buy BNB Tokens\u200b As all fees on BNB Chain are paid in BNB, therefore, in order to interact with the BNB Chain network you will need to have some BNB tokens. BNB tokens can also be received for usage on testnet through the testnet faucet. The BNB tokens for usage on mainnet are available for purchase on multiple leading exchanges and wallets as explained here. You can also refer [here][wallets/wallet-tutorial-overview] for tutorials on how to use different wallets for use with BNB Chain to send/receive/purchase BNB Tokens. Chain Explorer \u200b Chain Explorer provides a portal to explore blocks and transaction details. On Beacon Chain Explorer and BNB Smart Chain Explorer , you can also check different asset types, the distribution of their ownerships, and owners' transactions. REST API \u200b There are Accelerated Nodes which provide advanced API services for the public. Here is a list of all the Rest API information Accelerated Node provides: paths . For information regarding RPC Endpoints for BSC, refer here . Node RPC\u200b There are data seed nodes in the network which allow users to perform low-level operations like executing ABCI queries, viewing network/consensus state or broadcasting a transaction. If you run a full node by yourself, you can also use those RPC functions. Here is a list of all the Node RPC services it provides: for Beacon Chain refer here and for BNB Smart Chain refer here . Advanced Ways To Use BNB Chain\u200b Run your own full node\u200b Please refer to this guide about how to run your own full node on Beacon Chain and BNB Smart Chain . Run your own Light Client\u200b Please refer to this guide about how to run your own light client on Beacon Chain . Access via Node Command Line Interface (CLI) \u200b A Command Line Interface is available for Linux and Mac platforms. Please refer to the CLI Reference . Use SDKs\u200b SDKs are also provided as a starting point for your apps. There are two advanced SDK solutions for Beacon chain: Java and Golang . Both solutions provide functions for: Create wallets and manage keys Encode/sign transactions and submit to Binance Chain/DEX, including Transfer, New Order, Cancel Order, etc. Communicate with Binance Chain/DEX Node RPC calls through public node RPC services or your own private full nodes Please refer to specific SDK documentation for more information: Go(Documentation) Java(Documentation) Javascript (Documentation) C++(Documentation) C#(Documentation) Python(Documentation) Swift(Documentation) Blockchain Details\u200b Please check the technical details for more technical information.","title":"GettingStarted"},{"location":"GettingStarted/#getting-started","text":"The purpose of this tutorial is to give a general overview of BNB Chain and to serve as a starting point for new users to the BNB Chain ecosystem. General knowledge of cryptocurrency is assumed, and in particular familiarity with the Ethereum ecosystem. If you don't understand something right away, that's OK. Search for an answer online, and if you don't find it, ask on our Discord . We recommend reading this document entirely before using BNB Chain so that you can avoid common pitfalls and problems that new users run into. There are many multiple components of the BNB Chain, so it's best to get a full picture of things before diving in to save yourself confusion. You can find a general overview of BNB Chain here . It will be useful in understanding similarities and differences between BNB Chain and other platforms.","title":"Getting Started"},{"location":"GettingStarted/#bnb-chain-beacon-chain-and-bnb-smart-chain","text":"BNB Chain is composed of two blockchains - Beacon Chain (BC) and BNB Smart Chain (BSC). The Beacon Chain is the blockchain component that is responsible for the governance of the BNB Chain and manages staking and voting on the BNB Chain . Whereas, the BNB Smart Chain is the blokchain component that is EVM compatible, consensus layers, and with hubs to multi-chains.","title":"BNB Chain: Beacon Chain and BNB Smart Chain"},{"location":"GettingStarted/#what-can-you-do-with-beacon-chainbc","text":"The purpose of the Beacon Chain is to provide an efficient blockchain ecosystem that works along a DEX to provide an alternative marketplace for issuing and exchanging digital assets in a decentralized manner. You can: Send and receive BNB Issue new tokens to digitalize assets , and use Beacon Chain as underlying exchange/transfer network for the assets Send, receive, burn / mint and freeze / unfreeze tokens Sumbit an on-chain governance proposal for BNB Smart Chain For traders , you can: Propo*se to create trading pairs between two different tokens Send orders to buy or sell assets through trading pairs created on the chain withSDK Watch the DEX market to confirm price and market activity of certain assets For developers, you can also: Explore the transaction history and blocks on the chain, via Binance Chain Explore, API and node RPC interfaces. Run a full node to listen to and broadcast live updates on transactions, blocks, and consensus activities Extract other data of Binance Chain via full node or APIs Develop tools and applications to help users use Binance Chain and Binance DEX","title":"What can you do with Beacon Chain(BC)?\u200b"},{"location":"GettingStarted/#what-can-you-do-with-bnb-smart-chain-bsc","text":"BNB Smart Chain (BSC) is best described as a blockchain that runs in parallel to the Beacon Chain. Unlike Beacon Chain, BSC boasts smart contract functionality and compatibility with the Ethereum Virtual Machine (EVM). The design goal here was to leave the high throughput of Beacon Chain intact while introducing smart contracts into its ecosystem. Because BSC is EVM-compatible, it launched with support for the rich universe of Ethereum tools and DApps. In theory, this makes it easy for developers to port their projects over from Ethereum. For users, it means that applications like MetaMask can be easily configured to work with BSC. Seriously \u2013 it\u2019s just a matter of tweaking a couple of settings. Check out Use MetaMask for BNB Smart Chain to get started. You can: Send and receive BNB and other BEP2 tokens cross-chain Explore the transaction history and blocks on the chain, via bscscan , API and node RPC interfaces. Stake your BNB to earn some block rewards Developers can also: Issue new tokens to digitalize assets Migrate existing DApps Run a full node to listen to and broadcast live updates on transactions, blocks, and consensus activities Become a validator of BSC - testnet and [mainnet]](/docs/validator/guideline-mainnet) Develop wallets and tools to help users use Dapps","title":"What can you do with BNB Smart Chain (BSC)?\u200b"},{"location":"GettingStarted/#wallet","text":"The easiest way to use BNB Beacon and BNB Smart Chain is through a wallet with support for accounts and transfers on these chains. BNB Chain provides a Web Wallet at https://www.bnbchain.world/en . BNB Chain also provides Web Wallet for testnet at https://testnet.binance.org . Both provide the functions described below: Generating crypto keys and addresses, which serves as the base of a wallet Showing the balances of assets on the addresses Sending and receiving assets Binance Web Wallet also presents a trading UI, where you can examine market data and manage your orders to trade among the listed assets. BNB Smart Chain supports several popular wallets like MetaMask and TrustWallet , to learn more about the supported wallets refer here . For a list of tutorials on how to use other supported wallets with BNB Smart Chain, refer here .","title":"Wallet"},{"location":"GettingStarted/#bnb-token-and-fees","text":"BNB is the cryptocurrency coin that powers the BNB Chain ecosystem. As one of the world's most popular utility tokens, not only can you trade BNB like any other cryptocurrency, you can also use BNB in a wide range of applications and use cases. Although initially based on the Ethereum network, the ERC-20 BNB tokens were later swapped with BEP-2 BNB at a 1:1 ratio. The BEP-2 BNB is the native coin of the Beacon Chain, and the mainnet. In 2020, the BNB Smart Chain (BSC) was launched. BSC is a blockchain network that runs in parallel with the BNB Beacon Chain. This means that BNB can be found in three different forms: BNB BEP-2 on the BNB Beacon Chain. BNB BEP-20 on the BNB Smart Chain. BNB ERC-20 on the Ethereum network.","title":"BNB Token and Fees\u200b"},{"location":"GettingStarted/#how-to-buy-bnb-tokens","text":"As all fees on BNB Chain are paid in BNB, therefore, in order to interact with the BNB Chain network you will need to have some BNB tokens. BNB tokens can also be received for usage on testnet through the testnet faucet. The BNB tokens for usage on mainnet are available for purchase on multiple leading exchanges and wallets as explained here. You can also refer [here][wallets/wallet-tutorial-overview] for tutorials on how to use different wallets for use with BNB Chain to send/receive/purchase BNB Tokens.","title":"How to Buy BNB Tokens\u200b"},{"location":"GettingStarted/#chain-explorer","text":"\u200b Chain Explorer provides a portal to explore blocks and transaction details. On Beacon Chain Explorer and BNB Smart Chain Explorer , you can also check different asset types, the distribution of their ownerships, and owners' transactions.","title":"Chain Explorer"},{"location":"GettingStarted/#rest-api","text":"\u200b There are Accelerated Nodes which provide advanced API services for the public. Here is a list of all the Rest API information Accelerated Node provides: paths . For information regarding RPC Endpoints for BSC, refer here .","title":"REST API"},{"location":"GettingStarted/#node-rpc","text":"There are data seed nodes in the network which allow users to perform low-level operations like executing ABCI queries, viewing network/consensus state or broadcasting a transaction. If you run a full node by yourself, you can also use those RPC functions. Here is a list of all the Node RPC services it provides: for Beacon Chain refer here and for BNB Smart Chain refer here .","title":"Node RPC\u200b"},{"location":"GettingStarted/#advanced-ways-to-use-bnb-chain","text":"","title":"Advanced Ways To Use BNB Chain\u200b"},{"location":"GettingStarted/#run-your-own-full-node","text":"Please refer to this guide about how to run your own full node on Beacon Chain and BNB Smart Chain .","title":"Run your own full node\u200b"},{"location":"GettingStarted/#run-your-own-light-client","text":"Please refer to this guide about how to run your own light client on Beacon Chain .","title":"Run your own Light Client\u200b"},{"location":"GettingStarted/#access-via-node-command-line-interface-cli","text":"\u200b A Command Line Interface is available for Linux and Mac platforms. Please refer to the CLI Reference .","title":"Access via Node Command Line Interface (CLI)"},{"location":"GettingStarted/#use-sdks","text":"SDKs are also provided as a starting point for your apps. There are two advanced SDK solutions for Beacon chain: Java and Golang . Both solutions provide functions for: Create wallets and manage keys Encode/sign transactions and submit to Binance Chain/DEX, including Transfer, New Order, Cancel Order, etc. Communicate with Binance Chain/DEX Node RPC calls through public node RPC services or your own private full nodes Please refer to specific SDK documentation for more information: Go(Documentation) Java(Documentation) Javascript (Documentation) C++(Documentation) C#(Documentation) Python(Documentation) Swift(Documentation)","title":"Use SDKs\u200b"},{"location":"GettingStarted/#blockchain-details","text":"Please check the technical details for more technical information.","title":"Blockchain Details\u200b"},{"location":"GovernanceofBsc/","text":"Governance of BSC Motivation\u200b There are many system parameters to control the behavior of the BSC: All these parameters of BSC system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. params of Staking/Slash/Oracle modules on BC All these parameters will be determined by BSC Validator Set together through a proposal-vote process based on their staking. Such the process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication if needed. Design Principles\u200b For BC: Codebase reuse: Reuse most of the structure of proposal and vote, and the logic about propose and vote. Cross chain package Available at once: The cross-chain package should be available once the proposal passed. Native params change take place at breath block: The param change of Staking/Slash/Oracle modules on BC take place at breath block after the proposal passed. For BSC: Uniform interface. The contracts who are interested in these parameters only need to implement the same interface. Extensible. When adding a new system contract, there is no need to modify any other contracts. Failure toleration. Validators could vote to skip false proposals and go on. Multiplexing. Now we have only parameters gov, but in the future, there will be more governance functions. Workflow\u200b Contract Interface\u200b Every contract that wants to subscribe param change event, should implement the following interface: function updateParam(string key, bytes calldata value) external Some following check must be done inside the interface: The msg sender must be the gov contract. Basic check of value. (length, value range) An example implementation: modifier onlyGov() { require(msg.sender == GOV_CONTRACT_ADDR, \"the msg sender must be the gov contract\"); _; } function updateParam(string key, bytes calldata value) external onlyGov{ if (key == \"relayerReward\"){ require(value.length == 32, \"the length of value is not 32 when update relayer_reward param\"); uint256 memory paramValue = TypesToBytes.ToUint256(0, value); require(paramValue >= MIN_RELAYER_REWARD, \"the relayerReward is smaller than the minimum value\"); require(paramValue <= MAX_RELAYER_REWARD, \"the relayerReward is bigger than the maximal value\"); relayerReward = paramValue\uff1b }else{ require(false, \"receive unknown param\"); } } Gov Contract\u200b Implement the cross chain contract interface: handlePackage(bytes calldata msgBytes, bytes calldata proof, uint64 height, uint64 packageSequence) And do the following steps: Basic check. Sequence check, Relayer sender check, block header sync check, merkel proof check. Check the msg type according to the first byte of msgBytes, only param change msg type is supported for now. Check and parse the msg bytes. Use a fixed gas to invoke the updateParam interface of target contract. Catch any exception and emit fail event if necessary, but let the process go on. Claim reward for the relayer and increase sequence. Workflow \u200b There are many system parameters to control the behavior of the BSC: All these parameters of BSC system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. params of Staking/Slash/Oracle/IBC modules on BC All these parameters will be determined by BSC Validator Set together through a proposal-vote process based on their staking. Such processes will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication when needed. Fee Table\u200b Transaction Type Fee Fee For Submit Smart Chain Proposal 10 BNBs Proposer Smart Chain Proposal Deposit 0.00125 BNB Proposer Smart Chain Proposal Vote 1 BNB Proposer Relayer reward 0.001 BNB system reward pool Global Parameters\u200b min-deposit : The threshold for submitting a proposal on mainnet is 1000BNB, and the threshold for submitting a proposal on testnet is 2000BNB Commands \u200b Query side chain proposals\u200b parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --status passed filter proposals by proposal status, status: deposit_period/voting_period/passed/rejected No --voter bnb1h9ymecpakr8p8lhchtah2xxx7x4xq099umclqu filter by proposals voted on by voted No ## mainnet ./bnbcli gov query-proposals --side-chain-id bsc --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov query-proposals --side-chain-id chapel --trust-node --chain-id Binance-Chain-Ganges Query side chain proposal\u200b parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes ## mainnet ./bnbcli gov query-proposal --proposal-id 1 --side-chain-id bsc --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov query-proposal --proposal-id 1 --side-chain-id chapel --trust-node --chain-id Binance-Chain-Ganges Query side chain parameters\u200b parameter name example comments required --side-chain-id chapel the id of side chain, default is native chain Yes ## mainnet ./bnbcli params side-params --side-chain-id bsc --trust-node ## testnet ./tbnbcli params side-params --side-chain-id chapel --trust-node Submit cross chain param change proposal. \u200b |parameter name | example | comments | required | | ------------- | ------ | ------- | --------- | | --chan-id | Binance-Chain-XXX | the chain id of binance chain | Yes | | --side-chain-id | chapel | the id of side chain, default is native chain | Yes | | --deposit | 200000000000:BNB | deposit of proposal | Yes | | --from | alice | Name or address of private key with which to sign | Yes | | --key | felonyThreshold | the parameter name on the side chain | Yes | | --target | 0x0000000000000000000000000000000000001001 | the address of the contract on side chain | Yes | | --title | \"test csc change\" | title of proposal | Yes | | --value | 0x000000000000000000000000000000000000000000000000000000000000001b | the specified value of the parameter on side chain, should encoded in hex | Yes | | --voting-period | 604800 | voting period in seconds (default 604800) | No | ## mainet ./bnbcli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000:BNB --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000:BNB --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Ganges Submit cross chain channel management proposal.\u200b parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:BNB deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --channel-id 1 the the channel id that want to manage Yes --enable true enable the channel or not (default true) Yes --title \"test csc change\" title of proposal Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./bnbcli side-chain submit-channel-manage-proposal --channel-id 2 --enable=true --deposit 200000000000:BNB --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli side-chain submit-channel-manage-proposal --channel-id 2 --enable=true --deposit 200000000000:BNB --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Ganges Submit side chain module param change proposal.\u200b parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:BNB deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --title \"test csc change\" title of proposal Yes --sc-param-file param.json the file of Side Chain params (json format) Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./bnbcli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000:BNB --voting-period 100 --side-chain-id bsc --title \"test proposal\" --from delegator1 --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000:BNB --voting-period 100 --side-chain-id chapel --title \"test proposal\" --from delegator1 --trust-node --chain-id Binance-Chain-Ganges Vote for side chain proposal\u200b parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --option Yes vote option {yes, no, no_with_veto, abstain} Yes ## mainnet ./bnbcli gov vote --from alice --side-chain-id bsc --proposal-id 1 --option Yes --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov vote --from alice --side-chain-id chapel --proposal-id 1 --option Yes --chain-id Binance-Chain-Ganges Deposit for side chain proposal\u200b parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --deposit Yes amount of deposit Yes ## mainnet ./bnbcli gov deposit --from alice --side-chain-id bsc --proposal-id 1 --deposit 1000000000:BNB --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov deposit --from alice --side-chain-id chapel --proposal-id 1 --deposit 1000000000:BNB --chain-id Binance-Chain-Ganges","title":"Governance of BSC"},{"location":"GovernanceofBsc/#governance-of-bsc","text":"","title":"Governance of BSC"},{"location":"GovernanceofBsc/#motivation","text":"There are many system parameters to control the behavior of the BSC: All these parameters of BSC system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. params of Staking/Slash/Oracle modules on BC All these parameters will be determined by BSC Validator Set together through a proposal-vote process based on their staking. Such the process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication if needed.","title":"Motivation\u200b"},{"location":"GovernanceofBsc/#design-principles","text":"For BC: Codebase reuse: Reuse most of the structure of proposal and vote, and the logic about propose and vote. Cross chain package Available at once: The cross-chain package should be available once the proposal passed. Native params change take place at breath block: The param change of Staking/Slash/Oracle modules on BC take place at breath block after the proposal passed. For BSC: Uniform interface. The contracts who are interested in these parameters only need to implement the same interface. Extensible. When adding a new system contract, there is no need to modify any other contracts. Failure toleration. Validators could vote to skip false proposals and go on. Multiplexing. Now we have only parameters gov, but in the future, there will be more governance functions.","title":"Design Principles\u200b"},{"location":"GovernanceofBsc/#workflow","text":"","title":"Workflow\u200b"},{"location":"GovernanceofBsc/#contract-interface","text":"Every contract that wants to subscribe param change event, should implement the following interface: function updateParam(string key, bytes calldata value) external Some following check must be done inside the interface: The msg sender must be the gov contract. Basic check of value. (length, value range) An example implementation: modifier onlyGov() { require(msg.sender == GOV_CONTRACT_ADDR, \"the msg sender must be the gov contract\"); _; } function updateParam(string key, bytes calldata value) external onlyGov{ if (key == \"relayerReward\"){ require(value.length == 32, \"the length of value is not 32 when update relayer_reward param\"); uint256 memory paramValue = TypesToBytes.ToUint256(0, value); require(paramValue >= MIN_RELAYER_REWARD, \"the relayerReward is smaller than the minimum value\"); require(paramValue <= MAX_RELAYER_REWARD, \"the relayerReward is bigger than the maximal value\"); relayerReward = paramValue\uff1b }else{ require(false, \"receive unknown param\"); } }","title":"Contract Interface\u200b"},{"location":"GovernanceofBsc/#gov-contract","text":"Implement the cross chain contract interface: handlePackage(bytes calldata msgBytes, bytes calldata proof, uint64 height, uint64 packageSequence) And do the following steps: Basic check. Sequence check, Relayer sender check, block header sync check, merkel proof check. Check the msg type according to the first byte of msgBytes, only param change msg type is supported for now. Check and parse the msg bytes. Use a fixed gas to invoke the updateParam interface of target contract. Catch any exception and emit fail event if necessary, but let the process go on. Claim reward for the relayer and increase sequence.","title":"Gov Contract\u200b"},{"location":"GovernanceofBsc/#workflow_1","text":"\u200b There are many system parameters to control the behavior of the BSC: All these parameters of BSC system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. params of Staking/Slash/Oracle/IBC modules on BC All these parameters will be determined by BSC Validator Set together through a proposal-vote process based on their staking. Such processes will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication when needed.","title":"Workflow"},{"location":"GovernanceofBsc/#fee-table","text":"Transaction Type Fee Fee For Submit Smart Chain Proposal 10 BNBs Proposer Smart Chain Proposal Deposit 0.00125 BNB Proposer Smart Chain Proposal Vote 1 BNB Proposer Relayer reward 0.001 BNB system reward pool","title":"Fee Table\u200b"},{"location":"GovernanceofBsc/#global-parameters","text":"min-deposit : The threshold for submitting a proposal on mainnet is 1000BNB, and the threshold for submitting a proposal on testnet is 2000BNB","title":"Global Parameters\u200b"},{"location":"GovernanceofBsc/#commands","text":"\u200b","title":"Commands"},{"location":"GovernanceofBsc/#query-side-chain-proposals","text":"parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --status passed filter proposals by proposal status, status: deposit_period/voting_period/passed/rejected No --voter bnb1h9ymecpakr8p8lhchtah2xxx7x4xq099umclqu filter by proposals voted on by voted No ## mainnet ./bnbcli gov query-proposals --side-chain-id bsc --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov query-proposals --side-chain-id chapel --trust-node --chain-id Binance-Chain-Ganges","title":"Query side chain proposals\u200b"},{"location":"GovernanceofBsc/#query-side-chain-proposal","text":"parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes ## mainnet ./bnbcli gov query-proposal --proposal-id 1 --side-chain-id bsc --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov query-proposal --proposal-id 1 --side-chain-id chapel --trust-node --chain-id Binance-Chain-Ganges","title":"Query side chain proposal\u200b"},{"location":"GovernanceofBsc/#query-side-chain-parameters","text":"parameter name example comments required --side-chain-id chapel the id of side chain, default is native chain Yes ## mainnet ./bnbcli params side-params --side-chain-id bsc --trust-node ## testnet ./tbnbcli params side-params --side-chain-id chapel --trust-node","title":"Query side chain parameters\u200b"},{"location":"GovernanceofBsc/#submit-cross-chain-param-change-proposal","text":"\u200b |parameter name | example | comments | required | | ------------- | ------ | ------- | --------- | | --chan-id | Binance-Chain-XXX | the chain id of binance chain | Yes | | --side-chain-id | chapel | the id of side chain, default is native chain | Yes | | --deposit | 200000000000:BNB | deposit of proposal | Yes | | --from | alice | Name or address of private key with which to sign | Yes | | --key | felonyThreshold | the parameter name on the side chain | Yes | | --target | 0x0000000000000000000000000000000000001001 | the address of the contract on side chain | Yes | | --title | \"test csc change\" | title of proposal | Yes | | --value | 0x000000000000000000000000000000000000000000000000000000000000001b | the specified value of the parameter on side chain, should encoded in hex | Yes | | --voting-period | 604800 | voting period in seconds (default 604800) | No | ## mainet ./bnbcli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000:BNB --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000:BNB --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Ganges","title":"Submit cross chain param change proposal."},{"location":"GovernanceofBsc/#submit-cross-chain-channel-management-proposal","text":"parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:BNB deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --channel-id 1 the the channel id that want to manage Yes --enable true enable the channel or not (default true) Yes --title \"test csc change\" title of proposal Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./bnbcli side-chain submit-channel-manage-proposal --channel-id 2 --enable=true --deposit 200000000000:BNB --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli side-chain submit-channel-manage-proposal --channel-id 2 --enable=true --deposit 200000000000:BNB --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id Binance-Chain-Ganges","title":"Submit cross chain channel management proposal.\u200b"},{"location":"GovernanceofBsc/#submit-side-chain-module-param-change-proposal","text":"parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:BNB deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --title \"test csc change\" title of proposal Yes --sc-param-file param.json the file of Side Chain params (json format) Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./bnbcli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000:BNB --voting-period 100 --side-chain-id bsc --title \"test proposal\" --from delegator1 --trust-node --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000:BNB --voting-period 100 --side-chain-id chapel --title \"test proposal\" --from delegator1 --trust-node --chain-id Binance-Chain-Ganges","title":"Submit side chain module param change proposal.\u200b"},{"location":"GovernanceofBsc/#vote-for-side-chain-proposal","text":"parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --option Yes vote option {yes, no, no_with_veto, abstain} Yes ## mainnet ./bnbcli gov vote --from alice --side-chain-id bsc --proposal-id 1 --option Yes --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov vote --from alice --side-chain-id chapel --proposal-id 1 --option Yes --chain-id Binance-Chain-Ganges","title":"Vote for side chain proposal\u200b"},{"location":"GovernanceofBsc/#deposit-for-side-chain-proposal","text":"parameter name example comments required --chan-id Binance-Chain-XXX the chain id of binance chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --deposit Yes amount of deposit Yes ## mainnet ./bnbcli gov deposit --from alice --side-chain-id bsc --proposal-id 1 --deposit 1000000000:BNB --chain-id Binance-Chain-Tigris ## testnet ./tbnbcli gov deposit --from alice --side-chain-id chapel --proposal-id 1 --deposit 1000000000:BNB --chain-id Binance-Chain-Ganges","title":"Deposit for side chain proposal\u200b"},{"location":"Tutorials/","text":"Tutorials In this section, we have provided tutorials on usage of different components of BNB Chain. Platform BNB Smart Chain Tutorial on How to Join BNB Smart Chain Mainnet as Validator Tutorial on How to Join BNB Smart Chain Testnet as Validator Tutorial on How to Create a Validator on BNB Smart Chain Testnet Tutorial on How to Run a Full Node on BNB Smart Chain Tutorial on How to Run a Local BNB Smart Chain Network Tutorial on How to Upgrade Geth (Full Node) on BNB Smart Chain BNB Beacon Chain Tutorial on How to Run Full Node on BNB Beacon Chain Mainnet Tutorial on How to Run Full Node on BNB Beacon Chain Testnet Tutorial on How to Get Extra Info from your Full Node Tutorial on How to Upgrade your Full Node on BNB Beacon Chain Tutorial on How to Run a Single Node on a Local Network Tutorial on How to Run BNB Beacon Chain Client Tutorial on How to Run Light Client on BNB Beacon Chain Staking and Delegation Tutorial on How to Stake BNB Tokens on BSC Tutorial on How to Delegate BNB Tokens on BSC Smart Contracts\u200b Tutorial on How to Write BEP20 (Proxy) Contacts Tutorial on How to Verify BEP20 (Proxy) Contacts Tutorial on How to Deploy and Test Smart Contracts on BSC]() Using Remix Using Truffle Using HardHat Tutorial on How to Verify Deployed Smart Contract on bscScan Smart Digital Assets\u200b BEP Tokens Tutorial on How to issue BEP20 Tokens Tutorial on How to Bind BEP2 and BEP20 Tokens Tutorial on How to Mirror BEP2 and BEP20 Tokens Tutorial on How to Sync BEP2 and BEP20 Supply Tutorial on How to perform Cross-Chain Transfer of BEP2 and BEP20 Tokens Between BC and BSC NFT Tutorial on How to implement Token URI Tutorial on How to deploy NFTs on BSC Wallets\u200b BNB Smart Chain Please refer here for a list of tutorials on different supported wallets. BNB Beacon Chain List of Supported Wallets Tutorial on How to Use Trust Wallet with Beacon Chain Tutorial on How to Use Ledger Nano S Hardware Wallet with Beacon Chain Tutorial on How to Use Trezor Hardware Wallet with Beacon Chain Tutorial on How to manage your BEP8 tokens in BNB Chain Testnet Web Wallet","title":"Tutorials"},{"location":"Tutorials/#tutorials","text":"In this section, we have provided tutorials on usage of different components of BNB Chain.","title":"Tutorials"},{"location":"Tutorials/#platform","text":"BNB Smart Chain Tutorial on How to Join BNB Smart Chain Mainnet as Validator Tutorial on How to Join BNB Smart Chain Testnet as Validator Tutorial on How to Create a Validator on BNB Smart Chain Testnet Tutorial on How to Run a Full Node on BNB Smart Chain Tutorial on How to Run a Local BNB Smart Chain Network Tutorial on How to Upgrade Geth (Full Node) on BNB Smart Chain BNB Beacon Chain Tutorial on How to Run Full Node on BNB Beacon Chain Mainnet Tutorial on How to Run Full Node on BNB Beacon Chain Testnet Tutorial on How to Get Extra Info from your Full Node Tutorial on How to Upgrade your Full Node on BNB Beacon Chain Tutorial on How to Run a Single Node on a Local Network Tutorial on How to Run BNB Beacon Chain Client Tutorial on How to Run Light Client on BNB Beacon Chain","title":"Platform"},{"location":"Tutorials/#staking-and-delegation","text":"Tutorial on How to Stake BNB Tokens on BSC Tutorial on How to Delegate BNB Tokens on BSC","title":"Staking and Delegation"},{"location":"Tutorials/#smart-contracts","text":"Tutorial on How to Write BEP20 (Proxy) Contacts Tutorial on How to Verify BEP20 (Proxy) Contacts Tutorial on How to Deploy and Test Smart Contracts on BSC]() Using Remix Using Truffle Using HardHat Tutorial on How to Verify Deployed Smart Contract on bscScan","title":"Smart Contracts\u200b"},{"location":"Tutorials/#smart-digital-assets","text":"BEP Tokens Tutorial on How to issue BEP20 Tokens Tutorial on How to Bind BEP2 and BEP20 Tokens Tutorial on How to Mirror BEP2 and BEP20 Tokens Tutorial on How to Sync BEP2 and BEP20 Supply Tutorial on How to perform Cross-Chain Transfer of BEP2 and BEP20 Tokens Between BC and BSC NFT Tutorial on How to implement Token URI Tutorial on How to deploy NFTs on BSC","title":"Smart Digital Assets\u200b"},{"location":"Tutorials/#wallets","text":"BNB Smart Chain Please refer here for a list of tutorials on different supported wallets. BNB Beacon Chain List of Supported Wallets Tutorial on How to Use Trust Wallet with Beacon Chain Tutorial on How to Use Ledger Nano S Hardware Wallet with Beacon Chain Tutorial on How to Use Trezor Hardware Wallet with Beacon Chain Tutorial on How to manage your BEP8 tokens in BNB Chain Testnet Web Wallet","title":"Wallets\u200b"},{"location":"tools/","text":"Tools and Ecosystem of BNB Smart Chain In order to check the latest updates on the ecosystem of the official GitHub Page . The goal of this page is to provide the current status of the open-source BNB Smart Chain Tech Stack and highlight the potential interesting projects that are most demanded by the BSC community and ecosystem. About BNB Smart Chain is an Ethereum EVM 100% compatible blockchain, and is very good at decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others. To get a better understanding of the current BSC landscope, we divide each of the layers into the various components which we feel are most important. We then highlight some of the existing projects as well as some potentially interesting projects that we would like to fund by Binance Accelerator Funds. If you see a component with 0 or 1 existing projects then it's likely that we would consider grant support in this area. By describing our areas of priority in detail we do not wish to preclude grant applications that address different areas that we may not have thought of. We would like to fund all projects that bring value to the ecosystem. This is a living document and we are relying on our community to contribute to this and help maintain it. Please feel free to make edits and additions via pull requests. Layers of BSC Stack\u200b In the below sections you can find a list of different layers of the BSC Stack. Explorer and Wallets\u200b Components Existing projects Potentially interesting projects BNBChain List Explorer BNBChain List Desktop Wallets Wise Safe (a port of Gnosis Safe), Mycrypto , Tokenpocket Browser Extensions Binance Wallet , MetaMask , MathWallet , SafePal Mobile Wallets MathWallet , TrustWallet , BitKeep , TokenPocket , SafePal , ONTO Wallet , Hyperpay , AlphaWallet , Cobo , Bridge Wallet Web (burner) Wallets Torus , MyEtherWallet CLI Wallet geth , Seth Multisignature Wallets MultiSigWallet gnosis Hardware Wallets Ledger , trezor Block Explorers BSCScan , BitQuery Validator Dashboards BSCScan , BSC-Staking Governance Dashboards UI for BSC proposal/vote Infrastructure\u200b Components Existing projects Potentially interesting projects API/Node access Ankr , Chainstack , NowNodes , QuickNode , Nodereal\u2019s Meganode Archive Node Service Chainstack , InfStones , QuickNode , Nodereal\u2019s Meganode Public RPC Endpoints RPC Endpoints More public nodes are encouraged Community Polling Dashboard snapshot Gas Station Network opengsn Faucet faucet Tools, APIs and Languages\u200b Components Existing projects Potentially interesting projects Smart Contract Languages Solidity , Vyper Dev Frameworks Truffle , Embark , Waffle , Dapp , OpenZeppelin SDK , hardhat IDEs BSC Studio , Remix , Intellij Solidity Plugin , chainide Lint Tools Solhint , Ethlint Testing Tools Solidity code coverage , Solidity function profiler , eth-tester Test blockchain networks bscnode , Ganache Security tools MythX , Mythril , Oyente , Securify , Solgraph , solc-verify ABI (Application Binary Interface) tools ABI decoder , ABI-gen , Ethereum ABI UI Monitoring Neufund - Smart Contract Watch , BlockScout , Terminal , Ethereum-watcher Frontend BSC APIs [Web3.js], Eth.js , Ethers.js , light.js Backend BSC APIs Web3.py , Web3.php , Java Web3 , Net Web3 , Ruby Web3 Goto BSC Developer Ecosystem to navigate the full list. Dapps infra\u200b Components Existing projects Potentially interesting projects Data Analytics && Visualization BSC.NEWS , DappRadar , dapp.com , CMC , dapp.review , DefiStation , BitQuery , PARSIQ Oracle Band Protocol , ChainLink , Sphinx Archive Data InfStones File Storage, Cloud Cross Chain Bridges AnySwap , renVM , NerveNetwork , JellySwap , PolyNetwork , Orbit Bridge Decentralized, trustless, Open Access Randomness Trusless, Decentralized Randomness solution Licensing Computation IoT Dapps\u200b Components Existing projects Potentially interesting projects Scalable Transactions roll-ups, DAG-based consensus mechanisms, side chains ZKP zkswap , loopring Identity/DID Ontology Blockpass , Bloom , Civic Social Networking prometeus Governance/DAO snapshot KOGE Aragon , DaoStack Gaming RocketGame , BambooSwap , Blink , Battle Pets , Arkane , Curvegrid NFT/Collectibles Alpaca.City , Juggernaut JGN , Thugs.Fi , Dego , NFTForGood.org , Bounce , Arkane , Curvegrid, ATTN, XWorld Games Knownorigin, Rarible, Opensea Community & Fans Realy, Chilz BTC Binance BTC, renBTC , anyBTC Stablecoins BUSD, VAI , QIAN , Ditto , bDollar Credit & Lending 7up.finance , Cream.finance , ForTube , Venus , CokeFinance Exchange & Liquidity BakerySwap , Bounce.Finance , BurgerSwap , [DODO], Equator.Finance , PancakeSwap , Spartan Protocol , bStable.finance , StableXSwap , Thugs.Fi , Unisave , BestSwap , UniFi , Tenet , UniTrade , Rubic , Jetfuel , Belt.fi , Yogi Earn & Aggregators Defi.money(YFII) , Dego , fry.World , Xend Finance , OpenOcean , BeefyFinance , dForce , Pancakebunny , Reef.finance , Bearn.fi , ACryptoS , Dexguru , Cross Pool Insurance Certik , Helmet , Soteria Cover Protocol Derivatives Hedget , Mettalex , Injective Protocol Hegic , FinNexus Options Payment SWFT , MultiSender Celer Network , Connext Asset Tokenization Bridge Protocol Harbor , Neufund Tools Unrekt Host\u200b Components Existing projects Potentially interesting projects Rust Go BSC Signatures\u200b | Components | Existing projects | Potentially interesting projects | | Easy multisig scheme | | | | Validator HSMs | | | | Validator HSM-like solutions | | |","title":"Tools"},{"location":"tools/#tools-and-ecosystem-of-bnb-smart-chain","text":"In order to check the latest updates on the ecosystem of the official GitHub Page . The goal of this page is to provide the current status of the open-source BNB Smart Chain Tech Stack and highlight the potential interesting projects that are most demanded by the BSC community and ecosystem.","title":"Tools and Ecosystem of BNB Smart Chain"},{"location":"tools/#about","text":"BNB Smart Chain is an Ethereum EVM 100% compatible blockchain, and is very good at decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others. To get a better understanding of the current BSC landscope, we divide each of the layers into the various components which we feel are most important. We then highlight some of the existing projects as well as some potentially interesting projects that we would like to fund by Binance Accelerator Funds. If you see a component with 0 or 1 existing projects then it's likely that we would consider grant support in this area. By describing our areas of priority in detail we do not wish to preclude grant applications that address different areas that we may not have thought of. We would like to fund all projects that bring value to the ecosystem. This is a living document and we are relying on our community to contribute to this and help maintain it. Please feel free to make edits and additions via pull requests.","title":"About"},{"location":"tools/#layers-of-bsc-stack","text":"In the below sections you can find a list of different layers of the BSC Stack.","title":"Layers of BSC Stack\u200b"},{"location":"tools/#explorer-and-wallets","text":"Components Existing projects Potentially interesting projects BNBChain List Explorer BNBChain List Desktop Wallets Wise Safe (a port of Gnosis Safe), Mycrypto , Tokenpocket Browser Extensions Binance Wallet , MetaMask , MathWallet , SafePal Mobile Wallets MathWallet , TrustWallet , BitKeep , TokenPocket , SafePal , ONTO Wallet , Hyperpay , AlphaWallet , Cobo , Bridge Wallet Web (burner) Wallets Torus , MyEtherWallet CLI Wallet geth , Seth Multisignature Wallets MultiSigWallet gnosis Hardware Wallets Ledger , trezor Block Explorers BSCScan , BitQuery Validator Dashboards BSCScan , BSC-Staking Governance Dashboards UI for BSC proposal/vote","title":"Explorer and Wallets\u200b"},{"location":"tools/#infrastructure","text":"Components Existing projects Potentially interesting projects API/Node access Ankr , Chainstack , NowNodes , QuickNode , Nodereal\u2019s Meganode Archive Node Service Chainstack , InfStones , QuickNode , Nodereal\u2019s Meganode Public RPC Endpoints RPC Endpoints More public nodes are encouraged Community Polling Dashboard snapshot Gas Station Network opengsn Faucet faucet","title":"Infrastructure\u200b"},{"location":"tools/#tools-apis-and-languages","text":"Components Existing projects Potentially interesting projects Smart Contract Languages Solidity , Vyper Dev Frameworks Truffle , Embark , Waffle , Dapp , OpenZeppelin SDK , hardhat IDEs BSC Studio , Remix , Intellij Solidity Plugin , chainide Lint Tools Solhint , Ethlint Testing Tools Solidity code coverage , Solidity function profiler , eth-tester Test blockchain networks bscnode , Ganache Security tools MythX , Mythril , Oyente , Securify , Solgraph , solc-verify ABI (Application Binary Interface) tools ABI decoder , ABI-gen , Ethereum ABI UI Monitoring Neufund - Smart Contract Watch , BlockScout , Terminal , Ethereum-watcher Frontend BSC APIs [Web3.js], Eth.js , Ethers.js , light.js Backend BSC APIs Web3.py , Web3.php , Java Web3 , Net Web3 , Ruby Web3 Goto BSC Developer Ecosystem to navigate the full list.","title":"Tools, APIs and Languages\u200b"},{"location":"tools/#dapps-infra","text":"Components Existing projects Potentially interesting projects Data Analytics && Visualization BSC.NEWS , DappRadar , dapp.com , CMC , dapp.review , DefiStation , BitQuery , PARSIQ Oracle Band Protocol , ChainLink , Sphinx Archive Data InfStones File Storage, Cloud Cross Chain Bridges AnySwap , renVM , NerveNetwork , JellySwap , PolyNetwork , Orbit Bridge Decentralized, trustless, Open Access Randomness Trusless, Decentralized Randomness solution Licensing Computation IoT","title":"Dapps infra\u200b"},{"location":"tools/#dapps","text":"Components Existing projects Potentially interesting projects Scalable Transactions roll-ups, DAG-based consensus mechanisms, side chains ZKP zkswap , loopring Identity/DID Ontology Blockpass , Bloom , Civic Social Networking prometeus Governance/DAO snapshot KOGE Aragon , DaoStack Gaming RocketGame , BambooSwap , Blink , Battle Pets , Arkane , Curvegrid NFT/Collectibles Alpaca.City , Juggernaut JGN , Thugs.Fi , Dego , NFTForGood.org , Bounce , Arkane , Curvegrid, ATTN, XWorld Games Knownorigin, Rarible, Opensea Community & Fans Realy, Chilz BTC Binance BTC, renBTC , anyBTC Stablecoins BUSD, VAI , QIAN , Ditto , bDollar Credit & Lending 7up.finance , Cream.finance , ForTube , Venus , CokeFinance Exchange & Liquidity BakerySwap , Bounce.Finance , BurgerSwap , [DODO], Equator.Finance , PancakeSwap , Spartan Protocol , bStable.finance , StableXSwap , Thugs.Fi , Unisave , BestSwap , UniFi , Tenet , UniTrade , Rubic , Jetfuel , Belt.fi , Yogi Earn & Aggregators Defi.money(YFII) , Dego , fry.World , Xend Finance , OpenOcean , BeefyFinance , dForce , Pancakebunny , Reef.finance , Bearn.fi , ACryptoS , Dexguru , Cross Pool Insurance Certik , Helmet , Soteria Cover Protocol Derivatives Hedget , Mettalex , Injective Protocol Hegic , FinNexus Options Payment SWFT , MultiSender Celer Network , Connext Asset Tokenization Bridge Protocol Harbor , Neufund Tools Unrekt","title":"Dapps\u200b"},{"location":"tools/#host","text":"Components Existing projects Potentially interesting projects Rust Go BSC","title":"Host\u200b"},{"location":"tools/#signatures","text":"| Components | Existing projects | Potentially interesting projects | | Easy multisig scheme | | | | Validator HSMs | | | | Validator HSM-like solutions | | |","title":"Signatures\u200b"}]}